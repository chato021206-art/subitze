<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<!-- viewport-fit=cover „ÇíËøΩÂä†„Åó„Å¶ÂÖ®ÁîªÈù¢Ë°®Á§∫„ÇíÊúÄÈÅ©Âåñ -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>SNOW: SMASH SUBITIZING - v38.0 Particle Update</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Noto+Sans+JP:wght@900&display=swap" rel="stylesheet">
<script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
<style>
  :root {
    /* --- SMASH STYLE PALETTE --- */
    --bg-dark: #050505;

    /* High Contrast Grade Colors */
    --g-exc: #fff200;  /* Marvelous (Vivid Yellow) */
    --g-perf: #00ffff; /* Excellent (Cyan) */
    --g-grt: #00ff2a;  /* Great (Neon Green) */
    --g-good: #ffaa00; /* Good (Orange) */
    --g-ok:   #b0b0b0; /* OK (Silver) */
    --g-miss: #ff0033; /* Miss (Crimson) */

    /* Player Slot Colors (Vivid) */
    --c-easy: #55ff33;   /* Neon Green */
    --c-normal: #00aaff; /* Vivid Blue */
    --c-hard: #ffcc00;   /* Gold Yellow */
    --c-extreme: #ff0022;/* Radical Red */
    --c-random: #d000ff; /* Purple for Random */

    /* Font */
    --font-ui: 'Montserrat', 'Noto Sans JP', sans-serif;
    --font-num: 'Montserrat', sans-serif;

    /* ‚òÖ RESPONSIVE UNITS ‚òÖ */
    --block-size-base: min(7.5vw, 30px);
    --block-size-2d: var(--block-size-base);
    --block-size-3d: calc(var(--block-size-base) * 1.1);
    --kb-height: clamp(180px, 30dvh, 280px);
    --footer-base-height: 80px;
    --safe-area-bottom: env(safe-area-inset-bottom, 0px);
    --footer-total-height: calc(var(--footer-base-height) + var(--safe-area-bottom));
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

  body {
    font-family: var(--font-ui);
    background-color: var(--bg-dark);
    color: #fff;
    margin: 0; padding: 0;
    display: flex; flex-direction: column;
    height: 100dvh; /* Dynamic Viewport Height */
    width: 100%;
    overflow: hidden;
    position: fixed; /* Prevent bounce scroll */
    user-select: none;
    background-image:
        linear-gradient(45deg, #1a1a1a 25%, transparent 25%, transparent 75%, #1a1a1a 75%, #1a1a1a),
        linear-gradient(45deg, #1a1a1a 25%, transparent 25%, transparent 75%, #1a1a1a 75%, #1a1a1a);
    background-size: 30px 30px;
    background-position: 0 0, 15px 15px;
  }

  /* „Ç≥„É≥„ÉÜ„Éä */
  .app-container {
    width: 100%; height: 100%;
    max-width: 600px; /* Max width for tablets/PC */
    margin: 0 auto;   /* Center align */
    display: flex; flex-direction: column;
    padding: 8px;
    padding-top: env(safe-area-inset-top, 8px); /* „Éé„ÉÉ„ÉÅÂØæÂøú */
    background: radial-gradient(circle at center, #2a2a2a 0%, #000 100%);
    position: relative; z-index: 1;
    transition: background 0.3s cubic-bezier(0.18, 0.89, 0.32, 1.28);
    box-shadow: 0 0 50px rgba(0,0,0,0.8);
  }

  .app-container.theme-easy { background: radial-gradient(circle at center, rgba(85, 255, 51, 0.15) 0%, #000 100%); }
  .app-container.theme-normal { background: radial-gradient(circle at center, rgba(0, 170, 255, 0.15) 0%, #000 100%); }
  .app-container.theme-hard { background: radial-gradient(circle at center, rgba(255, 204, 0, 0.15) 0%, #000 100%); }
  .app-container.theme-extreme { background: radial-gradient(circle at center, rgba(255, 0, 34, 0.15) 0%, #000 100%); }

  /* Slot Styling */
  .app-container.theme-easy #slot-1 { box-shadow: 0 0 25px rgba(85, 255, 51, 0.4); border: 2px solid rgba(85, 255, 51, 0.3); }
  .app-container.theme-normal #slot-1 { box-shadow: 0 0 25px rgba(0, 170, 255, 0.4); border: 2px solid rgba(0, 170, 255, 0.3); }
   
  .app-container.theme-hard #slot-1 { 
      background: rgba(255, 204, 0, 0.05); 
      box-shadow: 0 0 25px rgba(255, 204, 0, 0.4); 
      border: 2px solid rgba(255, 204, 0, 0.3);
      flex: 1; 
  }
  .app-container.theme-hard #slot-2 {
      flex: 1 !important; 
      opacity: 0.8;
      border-right: 1px dashed rgba(255,255,255,0.2);
  }
  .app-container.theme-hard #slot-3 { display: none !important; }

  .app-container.theme-extreme #slot-1 {
      flex: 100;
      border: 4px solid var(--c-extreme);
      background: rgba(50, 0, 0, 0.3);
      justify-content: flex-end;
      align-items: center;
      box-shadow: 0 0 40px rgba(255, 0, 34, 0.6), inset 0 0 20px rgba(255, 0, 34, 0.2);
  }
  .app-container.theme-extreme #slot-2,
  .app-container.theme-extreme #slot-3 { display: none !important; }

  .app-container.showing-result .stage-area { visibility: hidden; }

  .stage-area {
    flex: 1;
    display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
    position: relative; overflow: hidden;
    perspective: 900px;
    min-height: 0;
  }

  /* Version Label */
  .version-label {
      position: absolute; bottom: 6px; right: 8px;
      font-size: 10px; font-weight: 900; color: rgba(255,255,255,0.4);
      font-family: var(--font-num); pointer-events: none; z-index: 100;
      letter-spacing: 0px; font-style: italic;
  }

  /* Flash Overlay */
  .slot-flash-overlay {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 20; opacity: 0; transform-origin: bottom;
  }
  .flash-exc .slot-flash-overlay { background: linear-gradient(to top, rgba(255, 242, 0, 0.8) 0%, transparent 100%); animation: flashBeam 0.2s ease-out forwards; }
  .flash-perf .slot-flash-overlay { background: linear-gradient(to top, rgba(0, 255, 255, 0.8) 0%, transparent 100%); animation: flashBeam 0.2s ease-out forwards; }
  .flash-grt .slot-flash-overlay { background: linear-gradient(to top, rgba(0, 255, 42, 0.7) 0%, transparent 100%); animation: flashBeam 0.2s ease-out forwards; }
  .flash-good .slot-flash-overlay { background: linear-gradient(to top, rgba(255, 170, 0, 0.7) 0%, transparent 100%); animation: flashBeam 0.2s ease-out forwards; }
  .flash-ok .slot-flash-overlay { background: linear-gradient(to top, rgba(176, 176, 176, 0.7) 0%, transparent 100%); animation: flashBeam 0.2s ease-out forwards; }
  .flash-miss .slot-flash-overlay { background: linear-gradient(to top, rgba(255, 0, 51, 0.9) 0%, transparent 100%); animation: flashBeam 0.3s ease-out forwards; }
  @keyframes flashBeam { 0% { opacity: 1; height: 10%; } 100% { opacity: 0; height: 100%; } }

  /* SHUTTER EFFECT */
  #fail-shutter {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background:
          repeating-linear-gradient(45deg, #111, #111 20px, #000 20px, #000 40px),
          linear-gradient(to bottom, rgba(255,0,0,0.2), #000);
      background-blend-mode: overlay;
      display: flex; align-items: center; justify-content: center;
      transform: translateY(-100%);
      z-index: 5500; pointer-events: none;
      transition: transform 0.2s cubic-bezier(0.8, 0, 0.2, 1);
      box-shadow: 0 10px 50px rgba(0,0,0,1);
      border-bottom: 10px solid #222;
  }
  #fail-shutter.active { transform: translateY(0); pointer-events: auto; }

  #victory-shutter {
      position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
      background: linear-gradient(to top, rgba(255,255,255,1) 0%, rgba(255,255,255,0.8) 20%, rgba(255,255,255,0) 100%);
      z-index: 5500; pointer-events: none;
      display: flex; align-items: flex-end; justify-content: center;
      transition: height 0.4s cubic-bezier(0.16, 1, 0.3, 1);
      backdrop-filter: blur(4px);
  }
  #victory-shutter.active { height: 100%; pointer-events: auto; animation: beamPulse 0.8s ease-out forwards; }
  @keyframes beamPulse {
      0% { opacity: 0; height: 0%; }
      30% { opacity: 1; height: 100%; background: linear-gradient(to top, rgba(255,255,255,1) 0%, rgba(0, 170, 255, 0.5) 50%, rgba(0,0,0,0) 100%); }
      100% { opacity: 0; height: 100%; background: transparent; }
  }

  /* HUD MODE LABEL */
  .mode-label {
      position: absolute; top: 15px; right: 15px;
      font-size: 14px; font-weight: 900; font-style: italic; letter-spacing: -1px;
      padding: 6px 30px; transform: skewX(-15deg);
      background: #000; color: #fff;
      z-index: 90; display: none; text-transform: uppercase;
      box-shadow: 6px 6px 0 rgba(0,0,0,0.5);
      border: 4px solid currentColor;
      -webkit-text-stroke: 0;
      text-shadow: 1px 1px 0 #000;
  }
  .mode-label.show { display: block; }

  #btn-mode-toggle {
      position: absolute; top: 6px; 
      left: auto; right: 15px;
      pointer-events: auto;
      background: #222; border: 3px solid #555; color: #ddd;
      border-radius: 4px; padding: 6px 14px;
      font-family: var(--font-ui); font-weight: 900; font-size: 12px; font-style: italic;
      cursor: pointer; z-index: 2200;
      display: flex; align-items: center; gap: 8px; transition: all 0.1s;
      transform: skewX(-10deg);
      box-shadow: 4px 4px 0 rgba(0,0,0,0.8);
      letter-spacing: -0.5px;
  }
  #btn-mode-toggle span.check { font-size: 16px; color: #999; font-weight: 900; }
  #btn-mode-toggle:active { transform: skewX(-10deg) translateY(2px); box-shadow: 1px 1px 0 rgba(0,0,0,0.8); }
  #btn-mode-toggle.disabled { opacity: 0.1; pointer-events: none; }
  #btn-mode-toggle.random-on { background: #330033; border-color: #d000ff; color: #fff; box-shadow: 0 0 15px rgba(208, 0, 255, 0.4); }
  #btn-mode-toggle.random-on span.check { color: #d000ff; text-shadow: 0 0 5px #d000ff; }

  /* HOW TO BUTTON */
  .btn-how-to-common {
      position: absolute;
      pointer-events: auto;
      background: #004488; border: 3px solid #00aaff; color: #fff;
      border-radius: 4px; padding: 6px 14px;
      font-family: var(--font-ui); font-weight: 900; font-size: 12px; font-style: italic;
      cursor: pointer; z-index: 2200;
      display: flex; align-items: center; gap: 6px; transition: all 0.1s;
      transform: skewX(-10deg);
      box-shadow: 4px 4px 0 rgba(0,0,0,0.8);
      letter-spacing: -0.5px;
      text-shadow: 1px 1px 0 #000;
  }
  .btn-how-to-common:active { transform: skewX(-10deg) translateY(2px); box-shadow: 1px 1px 0 rgba(0,0,0,0.8); background: #003366; }
   
  #btn-how-to-opening { top: 6px; left: 15px; }
  #btn-how-to-bottom { top: auto; bottom: calc(var(--footer-total-height) - 10px); left: 15px; width: auto; position: absolute; z-index: 3200; display: none; }

  #conveyor-wrapper {
    width: 100%; height: 100%;
    display: flex; align-items: flex-end; justify-content: center;
    gap: 8px; 
    padding: 2vh 2vw 0 2vw;
    transform-style: preserve-3d; pointer-events: none;
  }
  .slot {
    flex: 1; height: calc(100% - 2vh);
    display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
    position: relative; transform-style: preserve-3d;
    background: rgba(20,20,20,0.6); border-radius: 4px 4px 0 0;
    border: 2px solid rgba(255,255,255,0.1); border-bottom: none;
    transition: flex 0.3s, opacity 0.3s; overflow: hidden;
  }
  #slot-1 { background: rgba(50,50,50,0.2); border: none; z-index: 10; position: relative; }

  .slot-timer-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; overflow: visible; filter: drop-shadow(0 0 5px currentColor); }
  .timer-path { fill: none; stroke-linecap: butt; stroke-linejoin: round; transition: stroke 0.1s linear; }

  .cluster-container { display: flex; align-items: flex-end; gap: 3px; padding-bottom: 12px; transform-style: preserve-3d; transition: transform 0.1s; }
  .block-column { display: flex; flex-direction: column-reverse; gap: 3px; width: var(--block-size-2d); transform-style: preserve-3d; }
   
  .block { 
      width: var(--block-size-2d); height: var(--block-size-2d); 
      border-radius: 2px; 
      box-shadow: inset 3px 3px 0 rgba(255,255,255,0.5), inset -3px -3px 0 rgba(0,0,0,0.4), 3px 3px 5px rgba(0,0,0,0.6); 
      border: 1px solid rgba(0,0,0,0.5); 
      position: relative; 
  }
  .cluster-container.random-layout { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; padding: 0; }
  .block.block-random { position: absolute; z-index: 10; }
  .block.mode-easy { background: var(--c-easy); }
  .block.mode-normal { background: var(--c-normal); }
  .block.mode-hard { background: var(--c-hard); }
  .block.mode-extreme { background: var(--c-extreme); border: 1px solid #500; }

  .cluster-container.real-3d { position: absolute; bottom: 10%; transform-style: preserve-3d; transform: rotateX(-20deg) rotateY(25deg); }
  .cube { width: var(--block-size-3d); height: var(--block-size-3d); position: absolute; transform-style: preserve-3d; }
  .face { position: absolute; width: 100%; height: 100%; border: 2px solid rgba(0,0,0,0.6); opacity: 1; }
  .face-front { transform: translateZ(calc(var(--block-size-3d)/2)); }
  .face-back { transform: rotateY(180deg) translateZ(calc(var(--block-size-3d)/2)); }
  .face-right { transform: rotateY(90deg) translateZ(calc(var(--block-size-3d)/2)); }
  .face-left { transform: rotateY(-90deg) translateZ(calc(var(--block-size-3d)/2)); }
  .face-top { transform: rotateX(90deg) translateZ(calc(var(--block-size-3d)/2)); filter: brightness(1.3); border: 1px solid rgba(255,255,255,0.5); }
  .face-bottom { transform: rotateX(-90deg) translateZ(calc(var(--block-size-3d)/2)); filter: brightness(0.5); }
   
  .cube.mode-easy .face { background: var(--c-easy); }
  .cube.mode-normal .face { background: var(--c-normal); }
  .cube.mode-hard .face { background: var(--c-hard); }
  .cube.mode-extreme .face { background: var(--c-extreme); }

  .virtual-keyboard { 
      position: relative; width: 100%; 
      height: var(--kb-height); 
      background: linear-gradient(150deg, #0a0a0a 0%, #151515 100%); 
      padding: 8px; 
      padding-bottom: max(8px, var(--safe-area-bottom));
      display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr); gap: 6px; z-index: 3000; border-top: 4px solid #333; pointer-events: auto; box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.8); 
  }
  .virtual-keyboard::before { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 10px); pointer-events: none; }
   
  .kb-key { 
      background: linear-gradient(to bottom, #2a2a2a, #111); 
      border-radius: 6px; 
      border: 2px solid #444; 
      box-shadow: 0 4px 0 #000, inset 0 2px 0 rgba(255,255,255,0.1); 
      color: #ccc; 
      font-family: var(--font-num); 
      display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; touch-action: manipulation; overflow: hidden; transition: all 0.05s; 
  }
  .kb-key:active, .kb-key.active-state { 
      transform: translateY(4px); 
      box-shadow: 0 0 0 #000; 
      background: linear-gradient(to bottom, #ffcc00, #ff9900); 
      color: #000; 
      border-color: #fff; 
  }
  .kb-key-main { font-size: clamp(24px, 5vh, 36px); font-weight: 900; font-style: italic; text-shadow: 2px 2px 0 #000; letter-spacing: -2px; }
  .kb-key.disabled { opacity: 0.15; pointer-events: none; box-shadow: none; border-color: #222; background: #000; }
  .kb-key.ripple::after { content: ''; position: absolute; inset: 0; background: rgba(255,255,255,0.8); opacity: 0; pointer-events: none; animation: keyFlash 0.15s ease-out; }
  @keyframes keyFlash { 0% { opacity: 0.8; } 100% { opacity: 0; } }

  .kb-key.kb-version {
      background: none;
      border: none;
      box-shadow: none;
      color: #444;
      font-size: 16px;
      font-weight: 900;
      pointer-events: none;
      opacity: 0.7;
  }

  #bottom-ui-container { 
      position: absolute; bottom: 0; left: 0; width: 100%; 
      height: var(--footer-total-height);
      display: none; align-items: flex-start; justify-content: center; 
      padding: 0 15px;
      padding-top: 10px;
      z-index: 3100; pointer-events: auto; transition: opacity 0.2s, filter 0.2s; 
  }
  #mode-select-container { display: flex; width: 100%; gap: 8px; justify-content: center; height: 55px; }
   
  .mode-btn { 
      flex: 1; height: 100%; font-family: var(--font-ui); border: 3px solid #fff; border-radius: 6px; transform: skewX(-15deg); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 6px 6px 0 rgba(0,0,0,0.8); position: relative; padding: 4px 0; overflow: hidden; transition: transform 0.1s, box-shadow 0.1s; color: #fff; 
      -webkit-text-stroke: 0; text-shadow: 1px 1px 1px #000;
  }
  .mode-btn:active { transform: skewX(-15deg) translateY(6px); box-shadow: 0 0 0 rgba(0,0,0,0); filter: brightness(1.2); }
  .mode-easy { background: linear-gradient(170deg, #55ff33 0%, #1a800d 100%); }
  .mode-normal { background: linear-gradient(170deg, #00aaff 0%, #004080 100%); }
  .mode-hard { background: linear-gradient(170deg, #ffcc00 0%, #997a00 100%); }
  .mode-extreme { background: linear-gradient(170deg, #ff0022 0%, #80000f 100%); }
  .mode-val { font-size: clamp(12px, 3.5vw, 18px); font-weight: 900; font-style: italic; text-transform: uppercase; white-space: nowrap; z-index: 1; letter-spacing: -1px; }
  .mode-btn.locked { opacity: 0.3; filter: grayscale(1); pointer-events: none; border-color: #333; color: #555; background: #111; }
  .mode-btn.locked .mode-val { display: none; }
  .mode-btn.locked::after { content: 'üîí'; font-size: 24px; display: block; z-index:1; color: #555; -webkit-text-stroke: 0; }
  .bottom-ui-dimmed { opacity: 0.25; filter: grayscale(0.6); pointer-events: none; }

  #tutorial-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); z-index: 4000; pointer-events: none; opacity: 0; transition: opacity 0.3s; }
  #tutorial-overlay.active { opacity: 1; pointer-events: auto; }
  .tute-item { position: absolute; display: flex; flex-direction: column; align-items: center; color: #fff; filter: drop-shadow(0 0 8px rgba(0,0,0,0.8)); }
  #tute-central-msg { 
      top: 45%; left: 50%; transform: translate(-50%, -50%); 
      width: 100%; z-index: 5000; display:flex; justify-content:center; flex-direction: column; align-items: center; gap: 16px; 
  }
   
  .tute-big-msg { 
      font-size: clamp(40px, 15vw, 100px); 
      font-weight: 900; font-style: italic; transition: transform 0.1s; letter-spacing: -6px; 
      color: #fff; display:none; margin-bottom: 20px; z-index: 5001;
      paint-order: stroke fill; -webkit-text-stroke: 2px #000; text-shadow: 5px 5px 0 #000;
  }
  .tute-big-msg.pop { transform: scale(1.8) skewX(-10deg); }

  .tute-start-btn { 
      padding: clamp(15px, 4vw, 20px) clamp(30px, 8vw, 50px); 
      border-radius: 8px; border: 4px solid #fff; 
      background: linear-gradient(170deg, #00aaff 0%, #004080 100%);
      color: #fff; 
      text-shadow: 3px 3px 0 #000; 
      paint-order: stroke fill;
      -webkit-text-stroke: 1.5px #000;
      font-size: clamp(24px, 8vw, 36px); 
      font-weight: 900; font-style: italic; letter-spacing: -2px; text-transform: uppercase; cursor: pointer; 
      box-shadow: 10px 10px 0 #000; transform: skewX(-12deg); transition: transform 0.1s, box-shadow 0.1s; position: relative; overflow: visible; z-index: 10; 
  }
  .tute-start-btn:active { 
      transform: skewX(-12deg) translateY(6px); box-shadow: 4px 4px 0 #000; 
      background: linear-gradient(170deg, #0088cc 0%, #003366 100%);
  }
  .tute-start-btn::before { 
      content: ''; position: absolute; inset: -10px; border-radius: inherit; 
      border: 8px solid rgba(0, 170, 255, 0.8); 
      opacity: 0; pointer-events: none; animation: modeSelectPulse 0.9s ease-out infinite; z-index: -1; 
  }
  @keyframes modeSelectPulse { 0% { transform: scale(0.95); opacity: 1; border-width: 8px; } 40% { opacity: 0.9; } 100% { transform: scale(1.35); opacity: 0; border-width: 0px; } }

  .tute-mode-select { display: none; width: 95%; max-width: 460px; flex-direction: row; gap: 8px; justify-content: center; }
  .tute-mode-select .mode-btn { height: clamp(60px, 15vh, 80px); }

  /* ------------------------------------------- */
  /* ‚òÖ‚òÖ‚òÖ HOW TO PLAY MODAL ‚òÖ‚òÖ‚òÖ */
  /* ------------------------------------------- */
  #how-to-modal {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      backdrop-filter: blur(10px);
      z-index: 7000; /* Result„Çà„Çä‰∏ä */
      display: none;
      flex-direction: column; align-items: center; justify-content: center;
      opacity: 0; transition: opacity 0.3s;
      padding: 20px;
      padding-top: calc(20px + env(safe-area-inset-top));
      padding-bottom: calc(20px + env(safe-area-inset-bottom));
  }
  #how-to-modal.active { display: flex; opacity: 1; pointer-events: auto; }

  .ht-container {
      width: 100%; max-width: 500px;
      height: 100%; 
      background: #111;
      border: 4px solid #fff;
      border-radius: 12px;
      transform: skewX(-2deg);
      box-shadow: 0 0 50px rgba(0, 170, 255, 0.2), 15px 15px 0 #000;
      position: relative;
      display: flex; flex-direction: column;
      overflow: hidden; 
  }
   
  .ht-header {
      background: linear-gradient(90deg, #00aaff, #004488);
      padding: 15px 20px;
      border-bottom: 3px solid #fff;
      display: flex; justify-content: space-between; align-items: center;
      flex-shrink: 0;
      z-index:10;
      box-shadow: 0 5px 10px rgba(0,0,0,0.5);
  }
  .ht-title {
      font-size: 24px; font-weight: 900; font-style: italic; color: #fff;
      paint-order: stroke fill; -webkit-text-stroke: 1.5px #000; text-shadow: 3px 3px 0 rgba(0,0,0,0.5);
      letter-spacing: -1px;
  }
  .ht-close-btn {
      background: #000; border: 2px solid #fff; color: #fff;
      width: 32px; height: 32px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      font-weight: 900; cursor: pointer; transition: transform 0.1s;
      box-shadow: 3px 3px 0 rgba(0,0,0,0.5);
  }
  .ht-close-btn:active { transform: scale(0.9); }

  .ht-body {
      padding: 20px 25px;
      padding-bottom: 80px; 
      background: 
          repeating-linear-gradient(45deg, rgba(255,255,255,0.03) 0, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 15px),
          radial-gradient(circle at center, #222 0%, #000 100%);
      display: flex; flex-direction: column; gap: 20px;
      overflow-y: auto; 
      -webkit-overflow-scrolling: touch; 
  }

  .ht-intro-box {
      border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; padding: 12px;
      background: rgba(255,255,255,0.05); text-align: center;
  }
  .ht-intro-title { color: #aaa; font-size: 10px; font-weight: 900; letter-spacing: 2px; margin-bottom: 6px; }
  .ht-intro-text { font-size: 13px; line-height: 1.6; color: #eee; font-weight: 700; font-family: var(--font-num); }
  .highlight { color: #00ffff; font-weight: 900; text-decoration: underline; }

  .ht-sec-title {
      font-size: 18px; font-weight: 900; font-style: italic; color: #fff;
      border-bottom: 4px solid #fff; margin-top: 10px; margin-bottom: 5px;
      padding-bottom: 4px; text-shadow: 2px 2px 0 #000;
      letter-spacing: -1px;
  }

  .ht-flow-step {
      display: flex; align-items: center; 
      background: rgba(0,0,0,0.4); 
      border: 1px solid #444; 
      border-radius: 8px; 
      padding: 15px 10px 10px 10px; 
      position: relative; 
      overflow: visible; 
      box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
      margin-top: 10px;
  }
  .ht-step-badge {
      position: absolute; 
      top: -10px; 
      left: 10px; 
      background: #fff; color: #000; 
      font-size: 10px; font-weight: 900; 
      padding: 2px 10px; 
      border-radius: 4px;
      border: 2px solid #000; 
      box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
      z-index: 5;
  }
  .ht-step-text { flex: 1; padding-left: 10px; }
  .step-head { font-size: 18px; font-weight: 900; color: var(--g-perf); margin-bottom: 2px; text-shadow: 1px 1px 0 #000; }
  .step-desc { font-size: 11px; color: #ccc; line-height: 1.3; font-family: var(--font-num); }
  .ht-step-icon { 
      width: 50px; height: 50px; display: flex; align-items: center; justify-content: center;
      background: rgba(255,255,255,0.1); border-radius: 50%;
  }
  .ht-step-icon i { width: 28px; height: 28px; color: #fff; }
  .ht-flow-arrow { text-align: center; color: #555; font-size: 10px; transform: scaleY(0.6); }

  .ht-judge-box { display: flex; flex-direction: column; gap: 10px; }
  .ht-judge-desc { font-size: 12px; color: #ccc; text-align: center; margin-bottom: 5px; line-height: 1.4; }
   
  .ht-meter-demo { 
      display: flex; align-items: center; gap: 8px; 
      background: #000; padding: 10px; border-radius: 6px; border: 1px solid #333; 
  }
  .meter-label { font-size: 10px; color: #888; font-weight: 900; width: 35px; text-align: center; }
  .meter-bar { flex: 1; height: 24px; display: flex; border-radius: 4px; overflow: hidden; }
  .m-seg { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 8px; font-weight: 900; color: #000; box-shadow: inset 0 0 2px rgba(0,0,0,0.5); }
  .seg-marv { background: var(--g-exc); flex: 1; }
  .seg-exc { background: var(--g-perf); flex: 1; }
  .seg-grt { background: var(--g-grt); flex: 1.5; }
  .seg-good { background: var(--g-good); flex: 2; }
  .seg-ok { background: var(--g-ok); flex: 2; }

  .ht-rank-grid {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-top: 5px;
  }
  .rank-cell {
      background: rgba(30, 30, 30, 0.6); 
      border: 2px solid currentColor; /* ÊñáÂ≠óËâ≤„Å´Êû†Á∑ö„Çí‰∏ÄËá¥„Åï„Åõ„Çã */
      border-radius: 6px; padding: 8px 0;
      text-align: center; font-weight: 900; font-size: 18px; font-style: italic;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      text-shadow: 1px 1px 0 #000;
      box-shadow: inset 0 0 10px rgba(255,255,255,0.05), 0 0 8px currentColor; /* ÊñáÂ≠óËâ≤„ÅßÁô∫ÂÖâ */
  }
   
  .c-secret { color: #555; }
  .c-s { color: #ffdd00; }
  .c-a { color: #00ffff; }
  .c-b { color: #00ff2a; }
  .c-c { color: #ffaa00; }
  .c-d { color: #b0b0b0; }

  .ht-mode-list { display: flex; flex-direction: column; gap: 10px; }
  .ht-mode-item {
      border: 2px solid #444; border-radius: 6px; overflow: hidden;
  }
  .m-easy { border-color: var(--c-easy); }
  .m-hard { border-color: var(--c-hard); }
  .m-random { border-color: var(--c-random); }

  .hm-head {
      padding: 6px 10px; font-size: 12px; font-weight: 900; font-style: italic; color: #000;
  }
  .m-easy .hm-head { background: var(--c-easy); }
  .m-hard .hm-head { background: var(--c-hard); }
  .m-random .hm-head { background: var(--c-random); color: #fff; text-shadow: 1px 1px 0 #000; }

  .hm-body { padding: 10px; font-size: 11px; line-height: 1.4; color: #ddd; background: rgba(0,0,0,0.5); }
  .hl { color: #fff; font-weight: 900; text-decoration: underline; }

  .ht-unlock-list { display: flex; flex-direction: column; gap: 8px; }
  .ht-unlock-item { display: flex; align-items: center; border-bottom: 1px solid #333; padding-bottom: 8px; }
  .ul-target { width: 80px; font-size: 12px; font-weight: 900; color: #fff; font-style: italic; }
  .ul-cond { flex: 1; font-size: 11px; color: #ccc; line-height: 1.3; font-family: var(--font-num); }
   
  .ht-ch-box {
      background: linear-gradient(135deg, #111 0%, #222 100%);
      border: 1px solid #555; border-radius: 8px; padding: 15px; text-align: center;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
  }
  .ch-big { font-size: 20px; font-weight: 900; font-style: italic; color: #fff; margin-bottom: 8px; text-shadow: 2px 2px 0 #000; }
  .ch-desc { font-size: 11px; color: #aaa; line-height: 1.5; font-family: var(--font-num); }

  .ht-footer {
      margin-top: 10px; padding-top: 15px; border-top: 1px dashed #444;
      text-align: center;
  }

  /* ------------------------------------------- */

  .eval-effect { 
      position: fixed; top: calc(20% - 30px - 3.0cm); left: 50%; transform: translateX(-50%) scale(0.35); 
      font-family: var(--font-ui); 
      font-size: min(50px, 12vw); /* Responsive Font Size */
      font-weight: 900; font-style: italic; letter-spacing: -3px; 
      z-index: 10000; pointer-events: none; 
      paint-order: stroke fill;
      -webkit-text-stroke: 2.5px #000; text-shadow: 4px 4px 0px rgba(0,0,0,0.8); 
      animation: SNOWHit 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; white-space: nowrap; 
  }
  @keyframes SNOWHit { 
      0% { transform: translateX(-50%) scale(2) rotate(-15deg); opacity: 0; } 
      20% { opacity: 1; transform: translateX(-50%) scale(0.9) rotate(0deg); } 
      40% { transform: translateX(-50%) scale(1.0); } 
      90% { opacity: 1; transform: translateX(-50%) scale(1.0); } 
      100% { transform: translateX(-50%) scale(1.2) translateY(-20px); opacity: 0; } 
  }

  .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 6000; display: none; flex-direction: column; align-items: center; justify-content: center; }
  .modal-overlay.show { display: flex; animation: fadeIn 0.2s; }
  @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }

  .result-card {
      width: 100%; height: 100%;
      background: #111;
      display: flex; flex-direction: column;
      position: relative; color: #fff;
      overflow: hidden;
      transition: background 0.5s;
  }
  
  /* --- BACKGROUND EFFECTS --- */
  .result-card::before {
      content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
      z-index: 0; pointer-events: none; opacity: 0.25;
      background: conic-gradient(from 0deg, transparent 0deg, rgba(255,255,255,0.2) 60deg, transparent 120deg, rgba(255,255,255,0.2) 180deg, transparent 240deg);
      animation: rotateBg 15s linear infinite;
      display: none;
  }
  @keyframes rotateBg {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
  }

  .result-card.bg-god::before { display: block; opacity: 0.3; }
  /* Z Rank Bg Effect: More aggressive red rotation */
  .result-card.bg-z::before { 
      display: block; 
      background: conic-gradient(from 0deg, transparent 0deg, rgba(255,0,0,0.3) 45deg, transparent 90deg, rgba(255,0,0,0.3) 135deg, transparent 180deg); 
      opacity: 0.5; 
      animation-duration: 6s; 
  }
  .result-card.bg-s::before { display: block; background: conic-gradient(from 0deg, transparent 0deg, rgba(255,255,0,0.1) 60deg, transparent 120deg); opacity: 0.2; }

  /* Dynamic Backgrounds */
  /* Z-Rank Background: Deep Void Red */
  .result-card.bg-z { 
      background: radial-gradient(circle at center, #220000 0%, #110000 60%, #000 100%); 
      box-shadow: inset 0 0 100px #300;
  }
  /* GOD Background: Celestial Platinum */
  .result-card.bg-god { 
      background: linear-gradient(to bottom, #fffbe0 0%, #ffd700 40%, #b8860b 80%, #000 100%);
  }

  .result-card.bg-s { background: radial-gradient(circle at center, #665500 0%, #332a00 80%, #000 100%); }
  .result-card.bg-a { background: radial-gradient(circle at center, #004444 0%, #002222 80%, #000 100%); }
  .result-card.bg-b { background: radial-gradient(circle at center, #004411 0%, #002208 80%, #000 100%); }
  .result-card.bg-c { background: radial-gradient(circle at center, #442200 0%, #221100 80%, #000 100%); }
  .result-card.bg-d { background: radial-gradient(circle at center, #222222 0%, #111 80%, #000 100%); }

  .result-scroll-area { 
      flex: 1; overflow-y: auto; 
      display: flex; flex-direction: column; 
      padding: 20px; 
      padding-bottom: calc(var(--footer-total-height) + 20px);
      padding-top: env(safe-area-inset-top, 20px);
      position:relative; z-index:2; 
      -webkit-overflow-scrolling: touch;
  }
  .res-header-row { display: flex; justify-content: space-between; align-items: center; padding-bottom: 8px; margin-bottom: 10px; flex-shrink: 0; position: relative; border-bottom: 4px solid #fff; }
  .res-title { font-size: 32px; font-weight: 900; font-style: italic; letter-spacing: -3px; paint-order: stroke fill; -webkit-text-stroke: 1.5px #000; text-shadow: 3px 3px 0 #000; }

  .res-status-msg {
      font-size: min(50px, 12vw);
      font-weight: 900; font-style: italic;
      margin-top: 10px; display: none;
      text-transform: uppercase; letter-spacing: -4px;
      paint-order: stroke fill;
      -webkit-text-stroke: 2px #000;
      transform: skewX(-10deg) scale(1, 1.1);
      filter: drop-shadow(5px 5px 0 #000);
      text-align: center; line-height: 0.9;
      padding-right: 0.2em;
  }
  .res-status-msg.show { display: block; animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
  @keyframes popIn { from { transform: translateY(20px) scale(0.5) skewX(-10deg); opacity: 0; } to { transform: translateY(0) scale(1) skewX(-10deg); opacity: 1; } }

  .status-clear {
      color: #fff;
      background: linear-gradient(to bottom, #fff 30%, #00aaff 60%, #003366 100%);
      -webkit-background-clip: text; color: transparent;
      -webkit-text-stroke: 2px #fff; 
  }
  .status-clear {
      -webkit-text-stroke: 0;
      text-shadow: 0 0 10px rgba(0,170,255,0.8);
      position: relative;
  }

  .res-unlock-wrapper { display: none; justify-content: center; margin-top: 20px; margin-bottom: 15px; }
  .res-unlock-wrapper.show { display: flex; }
   
  .unlock-badge {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 300px; 
      padding: 15px 0;
      background: #000;
      color: #fff;
      border: 6px solid currentColor;
      font-family: var(--font-ui);
      font-weight: 900;
      font-style: italic;
      text-transform: uppercase;
      transform: rotate(-3deg) scale(1);
      box-shadow: 15px 15px 0 rgba(0,0,0,1), 0 0 30px currentColor;
      animation: smashStampIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      position: relative;
      overflow: hidden;
      z-index: 100;
  }
   
  @keyframes smashStampIn {
      0% { transform: scale(3) rotate(15deg); opacity: 0; }
      70% { transform: scale(0.9) rotate(-5deg); opacity: 1; }
      100% { transform: scale(1) rotate(-3deg); opacity: 1; }
  }

  .unlock-badge::before {
      content: ''; position: absolute; top:0; left:0; width:100%; height:100%;
      background: repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,0.15) 10px, rgba(255,255,255,0.15) 20px);
      pointer-events: none;
  }

  .unlock-badge.mode-normal { color: #00aaff; background: #000c1a; border-color: #00aaff; }
  .unlock-badge.mode-hard { color: #ffcc00; background: #1a1400; border-color: #ffcc00; }
  .unlock-badge.mode-extreme { color: #ff0022; background: #1a0003; border-color: #ff0022; }

  .unlock-badge .main-text { 
      font-size: 42px; line-height: 0.85; letter-spacing: -3px;
      text-shadow: 4px 4px 0 #000; z-index: 1; 
      paint-order: stroke fill;
      -webkit-text-stroke: 2px #000;
      color: #fff;
  }
   
  .unlock-badge .sub-text { 
      font-size: 20px; margin-top: 6px; letter-spacing: 2px;
      background: #fff; color: #000; 
      padding: 2px 24px; font-weight: 900; z-index: 1;
      transform: skewX(-15deg);
      box-shadow: 4px 4px 0 rgba(0,0,0,0.8);
      border: 2px solid #000;
  }

  .res-mode-label { font-size: 12px; font-weight: 900; font-style: italic; padding: 4px 20px; background: #000; border-radius: 4px; letter-spacing: -0.5px; border: 3px solid #fff; transform: skewX(-15deg); box-shadow: 3px 3px 0 #000; }
  .rank-section { display: flex; flex-direction: column; align-items: center; margin-bottom: 10px; padding-bottom: 10px; position: relative; flex-shrink: 0; z-index: 5; }
  .rank-wrapper { display: flex; align-items: flex-end; justify-content: center; position: relative; width: 100%; text-align: center; }
   
  /* --- RANK CHAR STYLING --- */
  .rank-char { 
      font-family: var(--font-ui);
      font-style: normal; /* Fixed italic artifact */
      font-size: clamp(80px, 20vh, 110px); line-height: 0.8; font-weight: 900;
      transform: skewX(-15deg); 
      margin-right: 0; padding-right: 20px;
      paint-order: stroke fill;
      -webkit-text-stroke: 4px #000; filter: drop-shadow(8px 8px 0 rgba(0,0,0,0.8)); 
  }

  .rank-char.rank-nicetry { font-size: clamp(36px, 10vw, 50px); -webkit-text-stroke: 2.5px #000; margin-right: 0; padding-right: 0; color: #fff; letter-spacing: -3px; }

  /* GOD RANK (Updated) */
  .rank-god {
      background: linear-gradient(135deg, #ffffff 0%, #fffacd 20%, #ffd700 40%, #daa520 60%, #ffffff 100%);
      background-size: 200% 200%;
      -webkit-background-clip: text; color: transparent;
      -webkit-text-stroke: 0;
      animation: godShine 3s ease-in-out infinite;
      filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 30px rgba(255, 255, 255, 0.6));
      z-index: 10;
  }
  @keyframes godShine {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
  }


  /* ‚òÖ REVISED Z RANK STYLING (TRUE RED FRONT on BLACK BASE) ‚òÖ */
  .rank-z {
      position: relative;
      z-index: 10;
      
      /* Base Layer (Back/Outline): Solid Black */
      /* „Åì„Çå„Åå„ÄåË£è„Äç„ÇÑ„ÄåÂ••„Äç„Å´„Å™„ÇãÈªí„ÅÑÂúüÂè∞ */
      color: #000; 
      /* ÊñáÂ≠ó„ÅÆÂ§™„Åï„ÇíÂá∫„Åô„Åü„ÇÅ„Å´„Çπ„Éà„É≠„Éº„ÇØ„Çí‰ΩøÁî®„ÄÅÈöôÈñì„ÇÇÂüã„ÇÅ„Çã */
      -webkit-text-stroke: 6px #000; 
      paint-order: stroke fill;
      
      /* Èªí„ÅÑÂΩ±„ÇíËêΩ„Å®„Åó„Å¶ÈáçÂéöÊÑü„ÇíÂá∫„Åô */
      filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.8));
  }
  
  /* Front Layer (Face): Vivid Red Gradient */
  /* „Åì„Çå„Åå„ÄåË°®„Äç„Å´„Å™„ÇãËµ§„ÅÑÊñáÂ≠ó */
  .rank-z::after {
      content: 'Z';
      position: absolute; 
      top: 0; left: 0; 
      width: 100%; height: 100%;
      z-index: 1; /* ÊâãÂâç„Å´Ë°®Á§∫ */
      
      /* ÈÆÆÁÉà„Å™Ëµ§„ÅÆ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥ */
      background: linear-gradient(180deg, #ffdddd 0%, #ff0000 30%, #cc0000 70%, #660000 100%);
      -webkit-background-clip: text; 
      color: transparent;
      
      /* „Çπ„Éà„É≠„Éº„ÇØ„Å™„Åó„ÅßÁ¥îÁ≤ã„Å™Ëâ≤„Å†„Åë„ÇíË°®Á§∫ */
      -webkit-text-stroke: 0;
      
      /* Ëµ§„ÅÑÁô∫ÂÖâ„Ç®„Éï„Çß„ÇØ„Éà */
      filter: drop-shadow(0 0 5px rgba(255, 50, 50, 0.8));
  }

  .rank-s { color: #ffdd00; text-shadow: 4px 4px 0 #b38600; }
  .rank-a { color: #00ccff; text-shadow: 4px 4px 0 #005580; }
  .rank-b { color: #33ff55; text-shadow: 4px 4px 0 #0f4d1a; }
  .rank-c { color: #ff8800; text-shadow: 4px 4px 0 #804400; }
  .rank-f { color: #888; text-shadow: 4px 4px 0 #222; }

  .res-msg-platinum, .res-msg-nice { color: #ffffff !important; background: none !important; -webkit-background-clip: initial !important; filter: none !important; text-shadow: 3px 3px 0 #000 !important; font-weight: 900; -webkit-text-stroke: 1.5px #000 !important;}

  .nav-btn { pointer-events: auto; background: #333; color: #fff; width: 44px; height: 44px; border-radius: 50%; border: 3px solid #fff; font-size: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.1s; flex-shrink: 0; box-shadow: 4px 4px 0 #000; }
  .nav-btn:active { background: #fff; color:#000; transform: scale(0.9); box-shadow: 0 0 0 #000; }
  .nav-btn:disabled { opacity: 0; pointer-events: none; }

  /* NEW RECORD - SMASH STYLE */
  .new-record-badge {
      background: linear-gradient(to bottom, #fff 30%, #ffd700 60%, #b8860b 100%);
      -webkit-background-clip: text; color: transparent;
      -webkit-text-stroke: 0;
       
      font-size: 42px; 
      font-weight: 900;
      font-style: italic;
      line-height: 1.0;
      padding: 0 10px;
      margin-right: -10px; 
      margin-bottom: 5px;
       
      filter: drop-shadow(5px 5px 0px #000) drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
       
      display: none;
      align-items: center;
      justify-content: center;
      transform: skewX(-10deg) rotate(-3deg); 
      position: relative; z-index: 9999;
      letter-spacing: -3px;
      pointer-events: none;
  }
  .new-record-badge.show { display: inline-block; animation: badgePopSmash 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
  @keyframes badgePopSmash {
      0% { transform: scale(3) skewX(-10deg) rotate(10deg); opacity: 0; }
      100% { transform: scale(1) skewX(-10deg) rotate(-3deg); opacity: 1; }
  }

  .score-row-container { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; margin-top: 5px; margin-bottom: 5px; position: relative; z-index: 5000; }
  .total-score-box { 
      font-family: var(--font-ui); text-align: center; font-size: 38px; font-weight: 900; font-style: italic; color: #fff; text-shadow: 4px 4px 0 #000; letter-spacing: -2px; line-height: 1.0; 
      paint-order: stroke fill;
      -webkit-text-stroke: 1.5px #000; 
  }
  .total-score-box span.total-label { font-size: 14px; color: #ddd; display: block; margin-bottom: 2px; letter-spacing: 1px; text-transform: uppercase; text-shadow: 2px 2px 0 #000; font-weight: 900; -webkit-text-stroke: 0; font-style: normal; }
  .total-avg-label { display: block; margin-top: 4px; font-weight: 900; font-style: italic; text-shadow: 2px 2px 0 #000; -webkit-text-stroke: 0; }
  .total-avg-label .avg-text { font-size: 0.6em; color: #aaa; letter-spacing: 1px; margin-right: 4px; }
  .total-avg-label .avg-value { font-size: 1em; color: #fff; }

  .next-rank-line { margin-top: 8px; font-size: 18px; font-weight: 900; letter-spacing: -1px; opacity: 0.9; text-shadow: 2px 2px 0 #000; -webkit-text-stroke: 0.5px #000; font-style: italic; }

  .detail-table { width: 100%; margin-bottom: 5px; border-collapse: collapse; font-family: var(--font-num); font-size: 14px; }
  .detail-table th { text-align: left; color: #bbb; border-bottom: 2px solid #555; padding: 4px 4px; font-family: var(--font-ui); font-style: italic; font-weight: 900; font-size: 12px; letter-spacing: -0.5px; }
  .detail-table td { border-bottom: 1px solid #333; padding: 4px 4px; font-weight: 700; }
  .detail-table tr:last-child td { border-bottom: none; }
  .dt-grade { 
      font-weight: 900; font-family: var(--font-ui); font-style: italic; width: 35%; text-shadow: 2px 2px 0 #000; 
      -webkit-text-stroke: 0; 
      letter-spacing: -1px; 
  }
  .dt-count { text-align: right; width: 15%; color: #fff; }
  .dt-avg { text-align: right; width: 20%; color: #999; font-size: 12px; }
  .dt-score { text-align: right; font-weight: 900; color: #fff; width: 30%; letter-spacing: -1px; }
  .dt-sub { font-size: 10px; color: #777; margin-left: 2px; }

  .miss-log-container { background: transparent; padding: 0; margin-bottom: 0px; display: flex; flex-direction: column; flex: 1; overflow: hidden; min-height: 0; margin-top: 10px; }
  .miss-title { font-size: 16px; font-weight: 900; color: #fff; margin-bottom: 4px; font-style: italic; text-transform: uppercase; letter-spacing: -1px; flex-shrink: 0; text-shadow: 2px 2px 0 #000; -webkit-text-stroke: 0; }
  .miss-scroll-wrapper { flex: 1; overflow-y: visible; /* Let result-scroll-area handle scrolling */ display: flex; flex-direction: column; gap: 4px; }
  .feedback-row { display: flex; flex-direction: column; background: rgba(50,50,50,0.3); border-radius: 4px; overflow: hidden; flex-shrink: 0; border: 1px solid rgba(255,255,255,0.1); position: relative; }
  .fb-body { position: relative; height: 140px; display: flex; align-items: center; justify-content: center; overflow: hidden; transform-style: preserve-3d; perspective: 600px; }
  .fb-body-inner { width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
  .fb-body-inner.fb-2d { transform: scale(0.7); display:flex; justify-content:center; align-items:flex-end; }
  .fb-body-inner.fb-3d { transform: scale(0.7); margin-top: 2cm; }
  .fb-body-inner.fb-extreme { transform: scale(0.45); }
  .fb-footer { position: absolute; top: 4px; right: 6px; display: flex; justify-content: flex-end; align-items: center; padding: 2px 8px; background: #000; font-size: 11px; font-weight: 900; font-family: var(--font-num); color: #ccc; text-shadow: none; z-index: 10; border-radius: 4px; border: 1px solid #555; }
  .fb-val-correct { color: var(--c-easy); margin-left: 4px; font-size: 12px; font-weight: 900;}
  .fb-val-wrong { color: var(--g-miss); margin-left: 4px; font-size: 12px; font-weight: 900;}
  .fb-lbl { margin-left: 8px; color: #888; font-size: 9px; letter-spacing: 0px;}

  .result-footer { 
      position: absolute; bottom: 0; left: 0; width: 100%; 
      height: var(--footer-total-height); 
      padding: 0 30px;
      padding-bottom: var(--safe-area-bottom);
      background: linear-gradient(to top, #000 85%, transparent); 
      display: flex; align-items: center; justify-content: space-between; 
      gap: 10px; z-index: 10; 
  }

  .unified-btn {
      flex: 0 0 auto; 
      min-width: 220px; 
      height: 60px; 
      background: linear-gradient(170deg, #00aaff 0%, #004080 100%);
      color: #fff;
      font-family: var(--font-ui);
      font-size: 26px; 
      font-weight: 900;
      font-style: italic;
      letter-spacing: -1.5px;
      border: 4px solid #fff; 
      border-radius: 8px;
      cursor: pointer;
      transform: skewX(-12deg);
      box-shadow: 8px 8px 0 #000;
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0; 
      position: relative;
      z-index: 10000;
      text-shadow: 2px 2px 0 #000;
      paint-order: stroke fill;
      -webkit-text-stroke: 1.5px #000;
  }
  .unified-btn:active {
      transform: skewX(-12deg) translateY(4px);
      box-shadow: 2px 2px 0 #000;
      background: linear-gradient(170deg, #0088cc 0%, #003366 100%);
  }
  .unified-btn::before {
      content: '';
      position: absolute;
      inset: -8px;
      border-radius: inherit;
      border: 6px solid rgba(0, 170, 255, 0.8);
      opacity: 0;
      pointer-events: none;
      animation: modeSelectPulse 1.2s ease-out infinite;
      z-index: -1;
  }

  /* --- Z-RANK PARTICLE EFFECT (Endless Embers) --- */
  .z-particle {
      position: absolute;
      width: 4px; height: 4px;
      background: #ffcc00; /* Ember color */
      border-radius: 50%;
      pointer-events: none;
      opacity: 0;
      box-shadow: 0 0 4px #ff0000;
      mix-blend-mode: screen;
      z-index: 5; /* Behind text but above bg */
      bottom: -20px; /* Start below the view */
      animation: emberFloat linear infinite; /* Infinite loop */
  }
  @keyframes emberFloat {
      0% { transform: translateY(0) scale(0.5); opacity: 0; }
      10% { opacity: 1; }
      80% { opacity: 0.8; }
      100% { transform: translateY(-120vh) scale(1.2); opacity: 0; }
  }

  /* --- GOD-RANK PARTICLE EFFECT (Divine Rising Rays) --- */
  .god-particle {
      position: absolute;
      /* Gradient for a rising light pillar/ray */
      background: linear-gradient(to top, transparent, rgba(255, 255, 200, 0.8), #fff, transparent);
      width: 2px;
      /* Random height set via JS */
      bottom: -100px;
      opacity: 0;
      z-index: 5;
      pointer-events: none;
      mix-blend-mode: screen; /* Brighter blending */
      animation: godRise linear infinite;
  }
  @keyframes godRise {
      0% { transform: translateY(0) scaleY(0.5); opacity: 0; }
      20% { opacity: 0.8; transform: translateY(-30vh) scaleY(1); }
      100% { transform: translateY(-130vh) scaleY(1.5); opacity: 0; }
  }
</style>
</head>
<body>

  <div class="app-container" id="app-wrapper">
    <div class="version-label">v38.0 Particle Update</div>
    <div class="stage-area">
      <div id="fail-shutter"></div>
      <div id="victory-shutter"></div>
      <div id="hud-mode-label" class="mode-label">EASY</div>

      <!-- „Ç™„Éº„Éó„Éã„É≥„Ç∞ÁîªÈù¢ -->
      <div id="tutorial-overlay">
          <!-- RANDOM„Éú„Çø„É≥ -->
          <button id="btn-mode-toggle" onclick="toggleDimensionMode()">
              <span class="check">‚òê</span><span class="label">RANDOM</span>
          </button>

          <!-- HOW TO „Éú„Çø„É≥ (Opening & Mode Select) -->
          <button id="btn-how-to-opening" class="btn-how-to-common" onclick="openHowTo()">
              <i data-lucide="help-circle" size="14"></i> HOW TO PLAY
          </button>

          <div id="tute-count" class="tute-item"></div>
          <div id="tute-input" class="tute-item"></div>

          <div id="tute-central-msg" class="tute-item">
              <button id="tute-start-btn" class="tute-start-btn">MODE SELECT</button>

              <div id="tute-mode-select" class="tute-mode-select">
                  <button class="mode-btn mode-easy" onclick="handleModeSelect('EASY', this)">
                      <div class="mode-val">EASY</div>
                  </button>
                  <button class="mode-btn mode-normal" onclick="handleModeSelect('NORMAL', this)">
                      <div class="mode-val">NORMAL</div>
                  </button>
                  <button class="mode-btn mode-hard" onclick="handleModeSelect('HARD', this)">
                      <div class="mode-val">HARD</div>
                  </button>
                  <button class="mode-btn mode-extreme" onclick="handleModeSelect('EXTREME', this)">
                      <div class="mode-val">EXTREME</div>
                  </button>
              </div>

              <div id="tute-big-msg" class="tute-big-msg">READY</div>
          </div>
      </div>

      <div id="conveyor-wrapper">
        <div id="slot-1" class="slot">
          <div id="flash-overlay-1" class="slot-flash-overlay"></div>
          <div id="view-1" style="flex:1; display:flex; justify-content:center; align-items:flex-end; width:100%; height:100%;"></div>
        </div>
        <div id="slot-2" class="slot">
          <div id="view-2" style="flex:1; display:flex; justify-content:center; align-items:flex-end;"></div>
        </div>
        <div id="slot-3" class="slot">
          <div id="view-3" style="flex:1; display:flex; justify-content:center; align-items:flex-end;"></div>
        </div>
      </div>
    </div>

    <div class="virtual-keyboard" id="virtual-keyboard">
        <button class="kb-key" data-key="1"><div class="kb-key-main">1</div></button>
        <button class="kb-key" data-key="2"><div class="kb-key-main">2</div></button>
        <button class="kb-key" data-key="3"><div class="kb-key-main">3</div></button>
        <button class="kb-key" data-key="4"><div class="kb-key-main">4</div></button>
        <button class="kb-key" data-key="5"><div class="kb-key-main">5</div></button>
        <button class="kb-key" data-key="6"><div class="kb-key-main">6</div></button>
        <button class="kb-key" data-key="7"><div class="kb-key-main">7</div></button>
        <button class="kb-key" data-key="8"><div class="kb-key-main">8</div></button>
        <button class="kb-key" data-key="9"><div class="kb-key-main">9</div></button>
        <div class="kb-key kb-version">v38</div>
        <button class="kb-key" data-key="0"><div class="kb-key-main">0</div></button>
        <button class="kb-key" data-key="DEL"><div class="kb-key-main" style="font-size:18px;">DEL</div></button>
    </div>

    <div id="bottom-ui-container">
        <!-- HOW TO „Éú„Çø„É≥ (Bottom UI / Difficulty Select - ‰∫àÂÇô) -->
        <button id="btn-how-to-bottom" class="btn-how-to-common" onclick="openHowTo()">
            <i data-lucide="help-circle" size="14"></i> HELP
        </button>

        <div id="mode-select-container">
            <button class="mode-btn mode-easy active-mode" onclick="handleModeSelect('EASY', this)">
                <div class="mode-val">EASY</div>
            </button>
            <button class="mode-btn mode-normal" onclick="handleModeSelect('NORMAL', this)">
                <div class="mode-val">NORMAL</div>
            </button>
            <button class="mode-btn mode-hard" onclick="handleModeSelect('HARD', this)">
                <div class="mode-val">HARD</div>
            </button>
            <button class="mode-btn mode-extreme" onclick="handleModeSelect('EXTREME', this)">
                <div class="mode-val">EXTREME</div>
            </button>
        </div>
    </div>
  </div>

  <!-- HOW TO MODAL -->
  <div id="how-to-modal">
      <div class="ht-container">
          <div class="ht-header">
              <div class="ht-title">HOW TO PLAY</div>
              <div class="ht-close-btn" onclick="closeHowTo()">‚úï</div>
          </div>
          <div class="ht-body">
              
              <!-- SECTION 1: INTRO -->
              <div class="ht-intro-box">
                  <div class="ht-intro-title">BRAIN TRAINING</div>
                  <p class="ht-intro-text">
                      "Subitizing"Ôºà„Çµ„Éì„Çø„Ç§„Ç∏„É≥„Ç∞Ôºâ„Å®„ÅØ„ÄÅÊï∞„ÇíÊï∞„Åà„Åö„Å´<br>
                      <span class="highlight">Áõ¥ÊÑü„ÅßÁû¨ÊôÇ„Å´ÊääÊè°„Åô„ÇãËÉΩÂäõ</span>„ÅÆ„Åì„Å®„ÄÇ<br>
                      Áúº„Å®ËÑ≥„ÅÆÂèçÂ∞ÑÁ•ûÁµå„ÇíÊ•µÈôê„Åæ„ÅßÈ´ò„ÇÅ„ÇçÔºÅ
                  </p>
              </div>

              <!-- SECTION 2: FLOW -->
              <div class="ht-sec-title">GAME FLOW</div>
              
              <div class="ht-flow-step">
                  <div class="ht-step-badge">STEP 1</div>
                  <div class="ht-step-text">
                      <div class="step-head">‰∏ÄÁï™Â∑¶„ÇíË¶ã„ÇçÔºÅ</div>
                      <div class="step-desc">Â∑¶Á´Ø„ÅÆ„É¨„Éº„É≥„Åå„Çø„Éº„Ç≤„ÉÉ„Éà„Å†„ÄÇ<br>Ê¨°„ÄÖ„Å®Ëø´„Çã„Éñ„É≠„ÉÉ„ÇØ„ÇíÁû¨ÊôÇ„Å´Êçâ„Åà„Çç„ÄÇ</div>
                  </div>
                  <div class="ht-step-icon"><i data-lucide="eye"></i></div>
              </div>

              <div class="ht-flow-arrow">‚ñº</div>

              <div class="ht-flow-step">
                  <div class="ht-step-badge">STEP 2</div>
                  <div class="ht-step-text">
                      <div class="step-head">Áõ¥ÊÑü</div>
                      <div class="step-desc">„Äå1, 2, 3...„Äç„Å®Êï∞„Åà„Å¶„ÅØ„ÅÑ„Åë„Å™„ÅÑ„ÄÇ<br>„ÄåÂΩ¢„Äç„Å®„Åó„Å¶Êï∞„ÇíË™çË≠ò„Åô„Çã„Çì„Å†„ÄÇ</div>
                  </div>
                  <div class="ht-step-icon"><i data-lucide="brain-circuit"></i></div>
              </div>

              <div class="ht-flow-arrow">‚ñº</div>

              <div class="ht-flow-step">
                  <div class="ht-step-badge">STEP 3</div>
                  <div class="ht-step-text">
                      <div class="step-head">ÂÖ•Âäõ</div>
                      <div class="step-desc">Êï∞Â≠ó„Ç≠„Éº„ÇíÂè©„ÅëÔºÅ<br>„Çπ„Éî„Éº„Éâ„ÅåÈÄü„ÅÑ„Åª„Å©„Çπ„Ç≥„Ç¢„Ç¢„ÉÉ„Éó„ÄÇ</div>
                  </div>
                  <div class="ht-step-icon"><i data-lucide="zap" style="color:#fff700"></i></div>
              </div>

              <!-- SECTION 3: JUDGEMENT -->
              <div class="ht-sec-title">JUDGEMENT & RANK</div>
              <div class="ht-judge-box">
                  <p class="ht-judge-desc">
                      ÂõûÁ≠î„Åæ„Åß„ÅÆ„Çø„Ç§„É†„ÅåÈÄü„ÅÑ„Åª„Å©„ÄÅÂà§ÂÆö„Éê„Éº„ÅÆËâ≤„ÅåÂ§â„Çè„Çã„ÄÇ<br>
                      <span style="color:var(--g-exc)">ÈªÑËâ≤(MARVELOUS)</span>„ÇíÁ∂≠ÊåÅ„Åô„Çã„Å®‚Ä¶Ôºü
                  </p>
                  
                  <div class="ht-meter-demo">
                      <div class="meter-label">FAST</div>
                      <div class="meter-bar">
                          <div class="m-seg seg-marv">MARV</div>
                          <div class="m-seg seg-exc">EXC</div>
                          <div class="m-seg seg-grt">GRT</div>
                          <div class="m-seg seg-good">GOOD</div>
                          <div class="m-seg seg-ok">OK</div>
                      </div>
                      <div class="meter-label">SLOW</div>
                  </div>

                  <div class="ht-rank-grid">
                      <div class="rank-cell c-secret" style="grid-column: span 3;">???</div>
                      <div class="rank-cell c-s">S</div>
                      <div class="rank-cell c-a">A</div>
                      <div class="rank-cell c-b">B</div>
                      <div class="rank-cell c-c">C</div>
                      <div class="rank-cell c-d">D</div>
                  </div>
              </div>

              <!-- SECTION 4: MODES -->
              <div class="ht-sec-title">MODES</div>
              <div class="ht-mode-list">
                  <div class="ht-mode-item m-easy">
                      <div class="hm-head">EASY / NORMAL</div>
                      <div class="hm-body">Âü∫Êú¨„É¢„Éº„Éâ„ÄÇ<br>ÂÖ•Âäõ„ÅØÂ∏∏„Å´<span class="hl">1Ê°Å</span>„ÄÇ</div>
                  </div>
                  <div class="ht-mode-item m-hard">
                      <div class="hm-head">HARD / EXTREME</div>
                      <div class="hm-body">‰∏äÁ¥öËÄÖÂêë„Åë„ÄÇ<br>ÂÖ•Âäõ„ÅØÂ∏∏„Å´<span class="hl">2Ê°Å</span>„ÄÇ</div>
                  </div>
                  <div class="ht-mode-item m-random">
                      <div class="hm-head">RANDOM (Ë∂Ö‰∏äÁ¥öËÄÖÂêë„Åë)</div>
                      <div class="hm-body">ÈÖçÁΩÆ„ÅåÂÆåÂÖ®„Å´„Éê„É©„Éê„É©„Å´„Å™„Çã„Ç´„Ç™„Çπ„É¢„Éº„Éâ„ÄÇ<br>Á©∫ÈñìË™çË≠òËÉΩÂäõ„ÅÆÈôêÁïå„Å´Êåë„ÇÅ„ÄÇ<br>‚ÄªÂè≥‰∏ä„ÅÆ„Éú„Çø„É≥„ÅßON/OFFÂàáÊõø</div>
                  </div>
              </div>

              <!-- SECTION: UNLOCKS -->
              <div class="ht-sec-title">UNLOCK CONDITIONS</div>
              <div class="ht-unlock-list">
                  <div class="ht-unlock-item">
                      <span class="ul-target">NORMAL</span>
                      <span class="ul-cond">EASY„Åß <span class="c-a" style="font-weight:900;">„É©„É≥„ÇØA</span> ‰ª•‰∏ä</span>
                  </div>
                  <div class="ht-unlock-item">
                      <span class="ul-target">HARD</span>
                      <span class="ul-cond">EASY„Åß <span class="c-s" style="font-weight:900;">„É©„É≥„ÇØS</span> ‰ª•‰∏ä<br>„Åæ„Åü„ÅØ NORMAL„Åß <span class="c-a" style="font-weight:900;">„É©„É≥„ÇØA</span> ‰ª•‰∏ä</span>
                  </div>
                  <div class="ht-unlock-item">
                      <span class="ul-target">EXTREME</span>
                      <span class="ul-cond">NORMAL„Åß <span class="c-s" style="font-weight:900;">„É©„É≥„ÇØS</span> ‰ª•‰∏ä<br>„Åæ„Åü„ÅØ HARD„Åß <span class="c-a" style="font-weight:900;">„É©„É≥„ÇØA</span> ‰ª•‰∏ä</span>
                  </div>
              </div>

              <!-- SECTION 5: SCORE UNIT -->
              <div class="ht-sec-title">WHAT IS "ch"?</div>
              <div class="ht-ch-box">
                  <div class="ch-big">ch = Count per Hour</div>
                  <div class="ch-desc">
                      „Äå1ÊôÇÈñì„ÅÇ„Åü„Çä‰Ωï„Ç¢„Ç§„ÉÜ„É†Âá¶ÁêÜ„Åß„Åç„Çã„Åã„Äç„Å®„ÅÑ„ÅÜÁîüÁî£ÊÄß„ÅÆÊåáÊ®ô„ÄÇ<br>
                      Ê≠£Á¢∫„Åã„Å§È´òÈÄü„Å´Âá¶ÁêÜ„Åô„Çã„Åì„Å®„Åß„ÄÅ„Åì„ÅÆÊï∞ÂÄ§„ÅØË∑≥„Å≠‰∏ä„Åå„Çã„ÄÇ<br>
                      ÁõÆÊåá„Åõ„ÄÅ<span style="color:#fff700">10,000ch</span>Ë∂Ö„ÅàÔºÅ
                  </div>
              </div>
          </div>
      </div>
  </div>

  <!-- Result Modal -->
  <div id="result-modal" class="modal-overlay">
    <div id="result-card-container" class="result-card">
      <div class="result-scroll-area">
        <div class="res-header-row">
            <div class="res-title">RESULT</div>
            <div id="res-mode-label" class="res-mode-label">NORMAL</div>
        </div>

        <div class="rank-section">
            <div class="rank-wrapper">
                <div id="res-rank-char" class="rank-char">S</div>
                <div id="res-rank-label-text" class="rank-label-text" style="font-size:14px;color:#888;font-weight:900;font-style:italic;">RANK</div>
            </div>

            <div id="res-status-msg" class="res-status-msg">STAGE CLEAR</div>
            <div id="res-unlock-wrapper" class="res-unlock-wrapper"></div>

            <div id="res-msg" style="font-size:32px;font-weight:900;margin-top:5px;font-style:italic;color:var(--g-miss);text-shadow:3px 3px 0 #000;-webkit-text-stroke:0;"></div>
        </div>

        <div id="result-details">
            <table class="detail-table">
                <thead>
                    <tr>
                        <th>JUDGE</th>
                        <th style="text-align:right">COUNT</th>
                        <th style="text-align:right">AVG(s)</th>
                        <th style="text-align:right">SCORE</th>
                    </tr>
                </thead>
                <tbody id="detail-table-body"></tbody>
            </table>

            <div class="score-row-container">
                <div id="new-record-badge" class="badge-common new-record-badge">NEW RECORD!!</div>
                <div id="res-total-box" class="total-score-box"></div>
            </div>

            <div id="miss-log" class="miss-log-container">
                <div class="miss-title">FEEDBACK</div>
                <div id="miss-items-row" class="miss-scroll-wrapper"></div>
            </div>
        </div>
      </div>

      <div class="result-footer">
          <button id="hist-prev" class="nav-btn"><i data-lucide="chevron-left"></i></button>
          <button class="unified-btn" onclick="resetToIdle()">ONE MORE GAME</button>
          <button id="hist-next" class="nav-btn"><i data-lucide="chevron-right"></i></button>
      </div>
    </div>
  </div>

<script>
    lucide.createIcons();

    const CONFIG = {
        capPerItemSec: 0.1,
        capCh: 36000
    };

    const RANK_ORDER = ['GOD', 'Z', 'S', 'A', 'B', 'C', 'D', 'F'];

    const MODES = {
        'EASY': { 
            count: 10, time: 3.0, color: 'var(--c-easy)', type: 'STD',
            judgments: { marv: 0.5, exc: 1.0, great: 1.5, good: 2.0, ok: 3.0 },
            rankThresholds: { god: 12000, z: 10520, s: 7200, a: 5600, b: 3600, c: 1800, f: 0 }
        },
        'NORMAL': { 
            count: 10, time: 3.5, color: 'var(--c-normal)', type: 'STD',
            judgments: { marv: 0.9, exc: 1.5, great: 2.0, good: 3.5 },
            rankThresholds: { god: 10000, z: 8800, s: 4000, a: 2800, b: 2000, c: 1200, f: 0 }
        },
        'HARD': { 
            count: 10, time: 4.0, color: 'var(--c-hard)', type: 'HARD',
            judgments: { marv: 1.5, exc: 2.0, great: 4.0 },
            rankThresholds: { god: 6000, z: 4200, s: 2400, a: 1800, b: 1200, c: 900, f: 0 }
        },
        'EXTREME': { 
            count: 10, time: 5.0, color: 'var(--c-extreme)', type: 'EXT',
            judgments: { marv: 2.0, exc: 3.0, great: 5.0 },
            rankThresholds: { god: 4500, z: 3000, s: 1800, a: 1200, b: 900, c: 600, f: 0 }
        }
    };

    const STATE = {
        status: 'IDLE',
        is3DMode: false,
        isRandomMode: false,
        randomAtPlay: false,
        score: 0,
        queue: [],
        current: null,
        currentModeKey: 'EASY',
        rafId: null,
        lapStartTime: 0,
        totalPlayTime: 0,
        currentInput: '',
        statsDetail: { marvelous: { count:0, time:0 }, excellent: { count:0, time:0 }, great: { count:0, time:0 }, good: { count:0, time:0 }, ok: { count:0, time:0 } },
        missedLog: [],
        questionCount: 0,
        generatedCount: 0,
        isExtreme: false,
        isInputBlocked: false,
        saveData: {
            ranks2D: { EASY: null, NORMAL: null, HARD: null, EXTREME: null },
            ranks3D: { EASY: null, NORMAL: null, HARD: null, EXTREME: null },
            bestCH: 0,
            bestEasyCH: 0,
            modeScores: { EASY: 0, NORMAL: 0, HARD: 0, EXTREME: 0 }
        },
        history: [],
        historyIndex: 0,
        hasPlayedOnce: false,
        lastCount: null,
        lastShapeSig: null,
        consecutiveCountValue: 0, 
    };

    const UI = {
        appWrapper: document.getElementById('app-wrapper'),
        view1: document.getElementById('view-1'),
        view2: document.getElementById('view-2'),
        view3: document.getElementById('view-3'),
        slot1: document.getElementById('slot-1'),
        slot2: document.getElementById('slot-2'),
        slot3: document.getElementById('slot-3'),
        failShutter: document.getElementById('fail-shutter'),
        victoryShutter: document.getElementById('victory-shutter'),
        tutorialOverlay: document.getElementById('tutorial-overlay'),
        tuteBigMsg: document.getElementById('tute-big-msg'),
        hudModeLabel: document.getElementById('hud-mode-label'),
        btnModeToggle: document.getElementById('btn-mode-toggle'),
        resultModal: document.getElementById('result-modal'),
        resultCardContainer: document.getElementById('result-card-container'), 
        resRankChar: document.getElementById('res-rank-char'),
        resRankLabelText: document.getElementById('res-rank-label-text'),
        resMsg: document.getElementById('res-msg'),
        resStatusMsg: document.getElementById('res-status-msg'),
        resUnlockWrapper: document.getElementById('res-unlock-wrapper'),
        resModeLabel: document.getElementById('res-mode-label'),
        resTotalBox: document.getElementById('res-total-box'),
        newRecordBadge: document.getElementById('new-record-badge'),
        missLog: document.getElementById('miss-log'),
        missItemsRow: document.getElementById('miss-items-row'),
        detailTableBody: document.getElementById('detail-table-body'),
        histPrev: document.getElementById('hist-prev'),
        histNext: document.getElementById('hist-next'),
        bottomUi: document.getElementById('bottom-ui-container'),
        tuteCount: document.getElementById('tute-count'),
        tuteInput: document.getElementById('tute-input'),
        tuteStartBtn: document.getElementById('tute-start-btn'),
        tuteModeSelect: document.getElementById('tute-mode-select'),
        virtualKeyboard: document.getElementById('virtual-keyboard'),
        howToModal: document.getElementById('how-to-modal'),
        btnHowToBottom: document.getElementById('btn-how-to-bottom'),
        timerPathL: null,
        timerPathR: null
    };

    const KB = { keys: {} };

    function getModeDisplayName(key) { return key; }

    function isRankHigherOrEqual(current, target) {
        if (!current) return false;
        return RANK_ORDER.indexOf(current) <= RANK_ORDER.indexOf(target);
    }

    function getRankFromScore(score, modeName) {
        const thresholds = MODES[modeName].rankThresholds;
        if(score >= thresholds.god) return 'GOD';
        if(score >= thresholds.z) return 'Z';
        if(score >= thresholds.s) return 'S';
        if(score >= thresholds.a) return 'A';
        if(score >= thresholds.b) return 'B';
        if(score >= thresholds.c) return 'C';
        return 'D'; 
    }

    function openHowTo() {
        UI.howToModal.classList.add('active');
    }
     
    function closeHowTo() {
        UI.howToModal.classList.remove('active');
    }

    function setupSlotTimerSVG() {
        const container = UI.slot1;
        const existing = container.querySelector('.slot-timer-svg');
        if(existing) existing.remove();

        const w = container.offsetWidth;
        const h = container.offsetHeight;

        const ns = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(ns, "svg");
        svg.setAttribute("class", "slot-timer-svg");
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "100%");
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        svg.style.position = 'absolute';
        svg.style.left = '0';
        svg.style.top = '0';

        const cx = w / 2;

        const pathStrL = `M ${cx} ${h} L 0 ${h} L 0 0 L ${cx} 0`;
        const pathStrR = `M ${cx} ${h} L ${w} ${h} L ${w} 0 L ${cx} 0`;

        const pathL = document.createElementNS(ns, "path");
        pathL.setAttribute("d", pathStrL);
        pathL.setAttribute("class", "timer-path");
        pathL.style.strokeWidth = "8px";

        const pathR = document.createElementNS(ns, "path");
        pathR.setAttribute("d", pathStrR);
        pathR.setAttribute("class", "timer-path");
        pathR.style.strokeWidth = "8px";

        svg.appendChild(pathL);
        svg.appendChild(pathR);
        container.appendChild(svg);

        UI.timerPathL = pathL;
        UI.timerPathR = pathR;

        const lenL = pathL.getTotalLength();
        const lenR = pathR.getTotalLength();

        pathL.style.strokeDasharray = lenL;
        pathL.style.strokeDashoffset = 0;
        pathR.style.strokeDasharray = lenR;
        pathR.style.strokeDashoffset = 0;
    }

    function updateTimerSVG(pct, color) {
        if (!UI.timerPathL || !UI.timerPathR) return;

        const totalLenL = UI.timerPathL.getTotalLength();
        const totalLenR = UI.timerPathR.getTotalLength();

        const offsetL = totalLenL * (1 - pct);
        const offsetR = totalLenR * (1 - pct);

        UI.timerPathL.style.strokeDashoffset = offsetL;
        UI.timerPathR.style.strokeDashoffset = offsetR;

        UI.timerPathL.style.stroke = color;
        UI.timerPathR.style.stroke = color;
    }

    function resetTimerVisuals() {
        if (!UI.timerPathL || !UI.timerPathR) return;
        UI.timerPathL.style.transition = 'none';
        UI.timerPathR.style.transition = 'none';

        UI.timerPathL.style.strokeDashoffset = 0;
        UI.timerPathR.style.strokeDashoffset = 0;

        void UI.timerPathL.offsetWidth;

        UI.timerPathL.style.transition = 'stroke 0.1s linear';
        UI.timerPathR.style.transition = 'stroke 0.1s linear';
    }

    function updateThemeClass() {
        UI.appWrapper.classList.remove('theme-easy','theme-normal','theme-hard','theme-extreme');
        const key = STATE.currentModeKey;
        if (key === 'EASY') UI.appWrapper.classList.add('theme-easy');
        else if (key === 'NORMAL') UI.appWrapper.classList.add('theme-normal');
        else if (key === 'HARD') UI.appWrapper.classList.add('theme-hard');
        else if (key === 'EXTREME') UI.appWrapper.classList.add('theme-extreme');
    }

    window.onload = () => {
        ['1','2','3','4','5','6','7','8','9','0','DEL'].forEach(k => {
            KB.keys[k] = document.querySelector(`.kb-key[data-key="${k}"]`);
        });

        resetToIdle();

        UI.histPrev.addEventListener('click', () => changeHistory(-1));
        UI.histNext.addEventListener('click', () => changeHistory(1));

        if (UI.tuteStartBtn) {
            UI.tuteStartBtn.addEventListener('click', handleTapToStart);
        }

        const keys = document.querySelectorAll('.kb-key');
        keys.forEach(k => {
            if(!k.dataset.key) return;
            k.addEventListener('touchstart', (e) => { e.preventDefault(); triggerKey(k); }, {passive: false});
            k.addEventListener('mousedown', (e) => { e.preventDefault(); triggerKey(k); });
            const clearState = () => k.classList.remove('active-state');
            k.addEventListener('touchend', clearState);
            k.addEventListener('mouseup', clearState);
            k.addEventListener('mouseleave', clearState);
        });

        window.addEventListener('keydown', (e) => {
            if(e.repeat) return;

            if ((e.key === '.' || e.code === 'NumpadDecimal') && STATE.status === 'IDLE') {
                e.preventDefault();
                toggleDimensionMode();
                return;
            }

            if (STATE.isInputBlocked) {
                if(STATE.status === 'GAMEOVER' && e.key === 'Enter') resetToIdle();
                return;
            }

            if(STATE.status === 'PLAYING') {
                const mode = MODES[STATE.currentModeKey];
                
                if (mode.type === 'EXT' || mode.type === 'HARD') {
                    if (e.key >= '0' && e.key <= '9') {
                        animateKey(e.key); processInputExtreme(e.key);
                    } else if (e.key === 'Backspace' || e.key === 'Delete') {
                        animateKey('DEL'); processInputExtreme('DEL');
                    }
                } else {
                    if(e.key >= '1' && e.key <= '9') {
                        animateKey(e.key); processInput(parseInt(e.key, 10));
                    }
                }
            } else if(STATE.status === 'IDLE') {
                if(e.key === 'Enter') handleModeSelect(STATE.currentModeKey);
                if(e.key === '1') handleModeSelect('EASY');
                if(e.key === '2') handleModeSelect('NORMAL');
                if(e.key === '3') handleModeSelect('HARD');
                if(e.key === '4') handleModeSelect('EXTREME');
            } else if(STATE.status === 'GAMEOVER') {
                if(e.key === 'Enter') resetToIdle();
            }
        });

        window.addEventListener('resize', () => {
             if (STATE.status === 'PLAYING') setupSlotTimerSVG();
        });

        updateModeButtons(STATE.currentModeKey);
    };

    function animateKey(kVal) {
        const btn = KB.keys[kVal];
        if(btn && !btn.classList.contains('disabled')) {
            btn.classList.add('active-state');
            triggerRipple(btn);
            setTimeout(() => btn.classList.remove('active-state'), 100);
        }
    }

    function updateKeyboardLayoutForMode() {
        const mode = MODES[STATE.currentModeKey];
        if (mode.type === 'EXT' || mode.type === 'HARD') {
            if(KB.keys['0']) KB.keys['0'].classList.remove('disabled');
            if(KB.keys['DEL']) KB.keys['DEL'].classList.remove('disabled');
        } else {
            if(KB.keys['0']) KB.keys['0'].classList.add('disabled');
            if(KB.keys['DEL']) KB.keys['DEL'].classList.add('disabled');
        }
    }

    function triggerKey(k) {
        if (STATE.isInputBlocked || k.classList.contains('disabled')) return;
        k.classList.add('active-state');
        triggerRipple(k);

        if(STATE.status === 'PLAYING') {
            const valStr = k.dataset.key;
            const mode = MODES[STATE.currentModeKey];
            if (mode.type === 'EXT' || mode.type === 'HARD') {
                processInputExtreme(valStr); 
            } else {
                let val = parseInt(valStr, 10);
                if (!Number.isNaN(val)) processInput(val);
            }
        }
    }

    function handleTapToStart() {
        if (STATE.status !== 'IDLE') return;
        if (STATE.isInputBlocked) return;
        if (UI.tuteStartBtn) UI.tuteStartBtn.style.display = 'none';
        if (UI.tuteModeSelect) {
            UI.tuteModeSelect.style.display = 'flex';
            
            // „É¢„Éº„Éâ„Çª„É¨„ÇØ„ÉàÁîªÈù¢„Å´„Å™„Å£„Åü„Çâ„ÄÅ‰∏ã„ÅÆHELP„Éú„Çø„É≥„ÇíË°®Á§∫„Åô„Çã
            if (UI.btnHowToBottom) UI.btnHowToBottom.style.display = 'flex';
            // Opening„ÅÆHOW TO„Éú„Çø„É≥„ÅØÈùûË°®Á§∫„Å´„Åó„Å™„ÅÑÔºàË¶ÅÊúõ„Å´„Çà„ÇäÂ∏∏ÈßêÔºâ
            // const opBtn = document.getElementById('btn-how-to-opening');
            // if(opBtn) opBtn.style.display = 'none';

            checkUnlocks();
        }
    }

    function toggleDimensionMode() {
        if (STATE.status !== 'IDLE') return;
        if (STATE.isInputBlocked) return;
        STATE.isRandomMode = !STATE.isRandomMode;
        updateToggleButtonText();
        resetToIdle();
    }

    function updateToggleButtonText() {
        if(STATE.isRandomMode) {
            UI.btnModeToggle.classList.add('random-on');
            UI.btnModeToggle.innerHTML = `<span class="check">‚òë</span><span class="label">RANDOM</span>`;
        } else {
            UI.btnModeToggle.classList.remove('random-on');
            UI.btnModeToggle.innerHTML = `<span class="check">‚òê</span><span class="label">RANDOM</span>`;
        }
    }

    function resetToIdle() {
        STATE.status = 'IDLE';
        STATE.isInputBlocked = false;

        UI.appWrapper.classList.remove('showing-result');

        STATE.isExtreme = (STATE.currentModeKey === 'EXTREME');
        updateThemeClass();

        UI.resultModal.classList.remove('show');
        UI.virtualKeyboard.style.visibility = 'visible';

        const oldSvg = UI.slot1.querySelector('.slot-timer-svg');
        if(oldSvg) oldSvg.remove();

        UI.slot1.style.border = '4px solid rgba(255,255,255,0.1)';
        UI.slot1.style.borderBottom = 'none';

        UI.failShutter.classList.remove('active');
        UI.failShutter.style.display = 'flex';

        UI.victoryShutter.classList.remove('active');
        UI.victoryShutter.style.transition = 'none';
        UI.victoryShutter.style.height = '0%';
        void UI.victoryShutter.offsetHeight;
        setTimeout(() => {
            UI.victoryShutter.style.transition = 'height 0.4s cubic-bezier(0.16, 1, 0.3, 1)';
        }, 50);

        UI.tutorialOverlay.classList.add('active');
        UI.hudModeLabel.classList.remove('show');

        const evals = document.querySelectorAll('.eval-effect');
        evals.forEach(e => e.remove());

        updateToggleButtonText();
        UI.btnModeToggle.classList.remove('disabled');

        UI.view1.innerHTML = ''; UI.view2.innerHTML = ''; UI.view3.innerHTML = '';

        checkUnlocks();
        document.querySelectorAll('.mode-btn').forEach(b => {
            b.style.transform = 'skewX(-15deg)';
            setTimeout(() => { b.style.transform = ''; }, 50);
        });
        updateModeButtons(STATE.currentModeKey);
        UI.bottomUi.classList.remove('bottom-ui-dimmed');

        UI.tuteBigMsg.style.display = 'none';
        UI.tuteBigMsg.classList.remove('pop');

        // HOW TO „É¢„Éº„ÉÄ„É´Èñâ„Åò„Çã
        closeHowTo();

        // Opening„ÅÆHOW TO„Éú„Çø„É≥„ÇíË°®Á§∫
        const opBtn = document.getElementById('btn-how-to-opening');
        if(opBtn) opBtn.style.display = 'flex';
        // Bottom„ÅÆHOW TO„Éú„Çø„É≥„ÅØÈùûË°®Á§∫
        if (UI.btnHowToBottom) UI.btnHowToBottom.style.display = 'none';

        if (!STATE.hasPlayedOnce) {
            if (UI.tuteStartBtn) UI.tuteStartBtn.style.display = 'inline-flex';
            if (UI.tuteModeSelect) UI.tuteModeSelect.style.display = 'none';
        } else {
            // ‰∏ÄÂ∫¶„Éó„É¨„Ç§„Åó„ÅüÂæå„ÅØ„É¢„Éº„Éâ„Çª„É¨„ÇØ„ÉàÁä∂ÊÖã„Å∏
            if(opBtn) opBtn.style.display = 'flex'; // ‚òÖ„Åì„Åì„ÇíÂ§âÊõ¥ÔºöÂ∏∏„Å´Ë°®Á§∫
            // if (UI.btnHowToBottom) UI.btnHowToBottom.style.display = 'flex'; // Bottom„ÅØÈùûË°®Á§∫„Åß„ÅÑ„ÅÑÔºà‰∏ä„Å´„ÅÇ„Çã„Åã„ÇâÔºâ

            if (UI.tuteStartBtn) UI.tuteStartBtn.style.display = 'none';
            if (UI.tuteModeSelect) UI.tuteModeSelect.style.display = 'flex';
        }

        updateKeyboardLayoutForMode();
    }

    function currentRanksStore() { return STATE.saveData.ranks2D; }

    function checkUnlocks() {
        const ranks = currentRanksStore();
        const easyRank    = ranks['EASY'];
        const normalRank = ranks['NORMAL'];
        const hardRank    = ranks['HARD'];
        const bestEasyCH = STATE.saveData.bestEasyCH || 0;

        const isNormalLocked = !(isRankHigherOrEqual(easyRank, 'A') || bestEasyCH >= 10000);
        const isHardLocked    = !(isRankHigherOrEqual(easyRank, 'S') || bestEasyCH >= 10000 || isRankHigherOrEqual(normalRank, 'A'));
        const isExtremeLocked= !(bestEasyCH >= MODES['EASY'].rankThresholds.z || isRankHigherOrEqual(normalRank, 'S') || isRankHigherOrEqual(hardRank, 'A'));

        const setLock = (sel, locked) => {
            document.querySelectorAll(sel).forEach(btn => {
                if(locked) btn.classList.add('locked');
                else btn.classList.remove('locked');
            });
        };

        setLock('.mode-easy', false);
        setLock('.mode-normal', isNormalLocked);
        setLock('.mode-hard', isHardLocked);
        setLock('.mode-extreme', isExtremeLocked);
    }

    function isModeLocked(modeKey) {
        const ranks = currentRanksStore();
        const easyRank    = ranks['EASY'];
        const normalRank = ranks['NORMAL'];
        const hardRank    = ranks['HARD'];
        const bestEasyCH = STATE.saveData.bestEasyCH || 0;

        if (modeKey === 'EASY') return false;
        if (modeKey === 'NORMAL') return !(isRankHigherOrEqual(easyRank, 'A') || bestEasyCH >= 10000);
        if (modeKey === 'HARD') return !(isRankHigherOrEqual(easyRank, 'S') || bestEasyCH >= 10000 || isRankHigherOrEqual(normalRank, 'A'));
        if (modeKey === 'EXTREME') return !(bestEasyCH >= MODES['EASY'].rankThresholds.z || isRankHigherOrEqual(normalRank, 'S') || isRankHigherOrEqual(hardRank, 'A'));
        return true;
    }

    function handleModeSelect(modeKey, btnEl) {
        if(STATE.status !== 'IDLE') return;
        if(STATE.isInputBlocked) return;
        if (isModeLocked(modeKey)) return;

        if (btnEl) triggerRipple(btnEl);

        STATE.currentModeKey = modeKey;
        STATE.isExtreme = (modeKey === 'EXTREME');
        updateThemeClass();

        updateModeButtons(modeKey);
        startCountdown();
    }

    function updateModeButtons(activeKey) {
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.remove('active-mode');
            if (btn.classList.contains('mode-easy') && activeKey === 'EASY') btn.classList.add('active-mode');
            if (btn.classList.contains('mode-normal') && activeKey === 'NORMAL') btn.classList.add('active-mode');
            if (btn.classList.contains('mode-hard') && activeKey === 'HARD') btn.classList.add('active-mode');
            if (btn.classList.contains('mode-extreme') && activeKey === 'EXTREME') btn.classList.add('active-mode');
        });
    }

    function startCountdown() {
        STATE.status = 'COUNTDOWN';
        STATE.isInputBlocked = true;
        STATE.hasPlayedOnce = true;

        UI.btnModeToggle.classList.add('disabled');
        UI.bottomUi.classList.add('bottom-ui-dimmed');
        
        // Countdwon‰∏≠„ÅØHOW TO„Éú„Çø„É≥Èö†„Åô
        if(UI.btnHowToBottom) UI.btnHowToBottom.style.display = 'none';
        const opBtn = document.getElementById('btn-how-to-opening');
        if(opBtn) opBtn.style.display = 'none';

        const seq = ['READY', '3', '2', '1'];
        let idx = 0;
        UI.tuteBigMsg.style.display = 'block';
        UI.tuteBigMsg.innerText = seq[0];
        UI.tuteBigMsg.classList.add('pop');

        if (UI.tuteStartBtn) UI.tuteStartBtn.style.display = 'none';
        if (UI.tuteModeSelect) UI.tuteModeSelect.style.display = 'none';

        const mode = MODES[STATE.currentModeKey];

        UI.hudModeLabel.innerText = `${STATE.currentModeKey}${STATE.isRandomMode ? ' [R]' : ''}`;
        UI.hudModeLabel.style.borderColor = mode.color;
        UI.hudModeLabel.style.color = mode.color;
        UI.hudModeLabel.classList.add('show');

        const timer = setInterval(() => {
            idx++;
            UI.tuteBigMsg.classList.remove('pop');
            void UI.tuteBigMsg.offsetWidth;

            if(idx < seq.length) {
                UI.tuteBigMsg.innerText = seq[idx];
                UI.tuteBigMsg.classList.add('pop');
            } else {
                clearInterval(timer);
                UI.tutorialOverlay.classList.remove('active');
                UI.tuteBigMsg.style.display = 'none';
                startGame();
            }
        }, 600);
    }

    function startGame() {
        STATE.status = 'PLAYING';
        STATE.isInputBlocked = false;
        STATE.score = 0;
        STATE.questionCount = 0;
        STATE.generatedCount = 0;
        STATE.totalPlayTime = 0;
        STATE.missedLog = [];
        STATE.queue = [];
        STATE.currentInput = '';
        STATE.statsDetail = { marvelous: { count:0, time:0 }, excellent: { count:0, time:0 }, great: { count:0, time:0 }, good: { count:0, time:0 }, ok: { count:0, time:0 } };
        STATE.randomAtPlay = STATE.isRandomMode;

        // Reset tracking vars
        STATE.lastCount = null;
        STATE.lastShapeSig = null;
        STATE.consecutiveCountValue = 0;

        UI.slot1.style.border = 'none';
        setupSlotTimerSVG();

        addQueueItem(); addQueueItem(); addQueueItem();
        STATE.current = STATE.queue.shift();
        renderQueue();

        resetTimerVisuals();

        STATE.lapStartTime = Date.now();
        if(STATE.rafId) cancelAnimationFrame(STATE.rafId);
        updateKeyboardLayoutForMode();
        gameLoop();
    }

    function gameLoop() {
        if(STATE.status !== 'PLAYING') return;

        const now = Date.now();
        const mode = MODES[STATE.currentModeKey];
        const currentLap = (now - STATE.lapStartTime) / 1000;

        if(currentLap > mode.time) {
            handleMiss("TIME", "-", STATE.current.count);
            return;
        }

        const maxTime = mode.time;
        const pct = Math.max(0, 1 - (currentLap / maxTime));
        const jud = mode.judgments;

        let colorCode = '#a0a0a0';

        if (currentLap <= jud.marv) colorCode = '#fff200'; // Marv (Yellow)
        else if (currentLap <= jud.exc) colorCode = '#00ffff'; // Exc (Cyan)
        else if (currentLap <= jud.great) colorCode = '#00ff2a'; // Great (Green)
        else if (jud.good && currentLap <= jud.good) colorCode = '#ffaa00'; // Good
        else if (jud.ok && currentLap <= jud.ok) colorCode = '#b0b0b0'; // OK
        else colorCode = '#ff0033'; // Danger

        updateTimerSVG(pct, colorCode);
        STATE.rafId = requestAnimationFrame(gameLoop);
    }

    function processInput(val) {
        if(!STATE.current || STATE.isInputBlocked) return;
        checkAnswer(val);
    }

    function processInputExtreme(key) {
        if(!STATE.current || STATE.isInputBlocked) return;
        
        if (key === 'DEL') {
            STATE.currentInput = STATE.currentInput.slice(0, -1);
            return;
        }

        const targetStr = String(STATE.current.count);
        const targetLen = targetStr.length;

        if (STATE.currentInput.length < targetLen) {
            STATE.currentInput += key;
        }

        if (STATE.currentInput.length === targetLen) {
            const val = parseInt(STATE.currentInput, 10);
            checkAnswer(val);
            STATE.currentInput = '';
        }
    }

    function checkAnswer(val) {
        const now = Date.now();
        let delta = (now - STATE.lapStartTime) / 1000;

        if(val === STATE.current.count) {
            const effectiveTime = Math.max(delta, CONFIG.capPerItemSec);
            STATE.totalPlayTime += effectiveTime;

            const mode = MODES[STATE.currentModeKey];
            const jud = mode.judgments;

            let gradeKey = "miss";
            let gradeLabel = "MISS";

            if (delta <= jud.marv) { gradeKey = "marvelous"; gradeLabel = "MARVELOUS"; }
            else if (delta <= jud.exc) { gradeKey = "excellent"; gradeLabel = "EXCELLENT"; }
            else if (delta <= jud.great) { gradeKey = "great"; gradeLabel = "GREAT"; }
            else if (jud.good && delta <= jud.good) { gradeKey = "good"; gradeLabel = "GOOD"; }
            else if (jud.ok && delta <= jud.ok) { gradeKey = "ok"; gradeLabel = "OK"; }
            else {
                handleMiss("SLOW", val, STATE.current.count);
                return;
            }

            STATE.statsDetail[gradeKey].count++;
            STATE.statsDetail[gradeKey].time += effectiveTime;

            triggerEvalEffect(gradeLabel);
            flashSlot(gradeLabel);

            if(STATE.questionCount >= mode.count - 1) {
                UI.view1.innerHTML = '';
                gameOver("FINISHED");
            } else {
                nextQuestion();
            }

        } else {
            handleMiss("TYPE", val, STATE.current.count);
        }
    }

    function flashSlot(grade) {
        const container = UI.slot1;
        const old = container.querySelector('.slot-flash-overlay');
        if(old) old.remove();

        const el = document.createElement('div');
        el.className = 'slot-flash-overlay';

        let cls = 'flash-ok';
        if(grade==='MARVELOUS') cls='flash-exc';
        else if(grade==='EXCELLENT') cls='flash-perf';
        else if(grade==='GREAT') cls='flash-grt';
        else if(grade==='GOOD') cls='flash-good';
        else if(grade==='MISS') cls='flash-miss';

        container.classList.remove('flash-exc','flash-perf','flash-grt','flash-good','flash-ok','flash-miss');
        container.classList.add(cls);
        container.appendChild(el);
    }

    function handleMiss(reason, input, answer) {
        let shapeCopy = STATE.is3DMode ? STATE.current.shape.map(r => [...r]) : [...STATE.current.shape];
        let layoutCopy = STATE.current.shape._rndPositions 
            ? STATE.current.shape._rndPositions.map(p => ({ x: p.x, y: p.y }))
            : null;

        STATE.missedLog.push({
            input: input,
            answer: answer,
            shape: shapeCopy,
            layout: layoutCopy,
            mode: STATE.currentModeKey,
            is3D: STATE.is3DMode,
            isRandom: STATE.randomAtPlay
        });
        STATE.totalPlayTime += (Date.now() - STATE.lapStartTime) / 1000;
        
        let msg = "NICE TRY";
        if (reason === "TIME") msg = "TIME OVER";
        else if (reason === "SLOW") msg = "TOO SLOW";

        flashSlot("MISS");
        gameOver(msg);
    }

    function nextQuestion() {
        STATE.questionCount++;
        if(STATE.queue.length < 3) addQueueItem();
        STATE.current = STATE.queue.shift();
        renderQueue();

        resetTimerVisuals();

        STATE.lapStartTime = Date.now();
        STATE.currentInput = '';
    }

    function triggerEvalEffect(text) {
        document.querySelectorAll('.eval-effect').forEach(e => e.remove());
        const el = document.createElement('div');
        el.className = 'eval-effect';
        el.innerText = text;

        let color = "#fff";
        if(text === "MARVELOUS") color = "var(--g-exc)";
        else if(text === "EXCELLENT") color = "var(--g-perf)";
        else if(text === "GREAT") color = "var(--g-grt)";
        else if(text === "GOOD") color = "var(--g-good)";

        el.style.color = color;

        document.body.appendChild(el);
        setTimeout(() => { if(el && el.parentNode) el.parentNode.removeChild(el); }, 1000);
    }

    function shapeSignature(shapeData, is3D) {
        try {
            if (!shapeData) return 'null';
            return JSON.stringify(shapeData);
        } catch(e) {
            return 'err';
        }
    }

    function addQueueItem() {
        const modeKey = STATE.currentModeKey;
        const mode = MODES[modeKey];
        if(STATE.generatedCount >= mode.count) {
            STATE.queue.push({ count: null, shape: [] });
            return;
        }

        let n;
        const maxAttempts = 2000;

        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            
            if (modeKey === 'EASY') {
                const r = Math.random() * 100;
                if (r < 28) n = 2;
                else if (r < 56) n = 3;
                else if (r < 85) n = 4;
                else n = 5;
            }
            else if (modeKey === 'NORMAL') {
                const r = Math.random() * 100;
                if (r < 10) n = 2;
                else if (r < 25) n = 3;
                else if (r > 90) n = 9;
                else n = 4 + Math.floor(Math.random() * 5); // 4-8
            }
            else if (modeKey === 'HARD') {
                // 1ÂïèÁõÆ„Åã„Çâ5ÂïèÁõÆ„ÅØ10ÔΩû15ÂÄã„ÄÅ6ÂïèÁõÆ‰ª•Èôç„ÅØ15ÔΩû19ÂÄã„ÅÆ„É©„É≥„ÉÄ„É†
                if (STATE.generatedCount < 5) {
                    // 10 to 15
                    n = Math.floor(10 + Math.random() * 6);
                } else {
                    // 15 to 19
                    n = Math.floor(15 + Math.random() * 5);
                }
            }
            else if (modeKey === 'EXTREME') {
                const q = STATE.generatedCount + 1;
                let min, max;
                if (q === 1) { min=13; max=16; }
                else if (q <= 3) { min=17; max=22; }
                else if (q <= 5) { min=23; max=29; }
                else if (q <= 7) { min=30; max=35; }
                else if (q <= 9) { min=36; max=39; }
                else { min=40; max=42; }
                n = Math.floor(min + Math.random() * (max - min + 1));
            }

            let maxH = 6;
            let cols = 3; 

            if(modeKey === 'EASY') { maxH = 3; cols = 3; }
            else if(modeKey === 'NORMAL') { maxH = 5; cols = 3; }
            else if(modeKey === 'HARD') { 
                maxH = 7; 
                // 2ÂõûÈÄ£Á∂ö„ÅßÊ®™„Åå5„Å´„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
                let lastCols = 0;
                if (STATE.queue.length > 0) {
                    const lastItem = STATE.queue[STATE.queue.length - 1];
                    if (lastItem && Array.isArray(lastItem.shape)) {
                        lastCols = lastItem.shape.length;
                    }
                }

                if (lastCols === 5) {
                    cols = 4;
                } else {
                    cols = Math.random() < 0.5 ? 4 : 5;
                }
            }
            else if(modeKey === 'EXTREME') { maxH = 9; cols = 9; }

            let shapeData, trueCount, sig;
            if (STATE.is3DMode) {
                shapeData = generateStadium3D_Strict(n, cols, maxH);
            } else {
                shapeData = generateShape2D_Connected(n, cols, maxH);
            }

            trueCount = 0;
            if (STATE.is3DMode) shapeData.forEach(r => r.forEach(h => trueCount += h));
            else shapeData.forEach(h => trueCount += h);
            if(trueCount === 0 && n > 0) trueCount = 1;

            sig = shapeSignature(shapeData, STATE.is3DMode);

            const isSameCount = (STATE.lastCount !== null && trueCount === STATE.lastCount);
            const isSameShape = (STATE.lastShapeSig !== null && sig === STATE.lastShapeSig);

            if (isSameShape) continue; 

            if (isSameCount) {
                if (STATE.consecutiveCountValue >= 2) {
                    continue;
                }
            }

            if (isSameCount) {
                STATE.consecutiveCountValue++;
            } else {
                STATE.consecutiveCountValue = 1;
            }
            
            STATE.lastCount = trueCount;
            STATE.lastShapeSig = sig;
            STATE.queue.push({ count: trueCount, shape: shapeData });
            break;
        }

        STATE.generatedCount++;
    }

    function generateShape2D_Connected(n, cols, maxHeight) {
        const arr = new Array(cols).fill(0);
        let currentIdx = Math.floor(cols / 2);
        arr[currentIdx]++;
        let placed = 1;

        let failCount = 0;

        while(placed < n) {
            let candidates = [];
            for(let i=0; i<cols; i++) {
                let isAdj = false;
                if(arr[i] > 0) isAdj = true;
                if(i > 0 && arr[i-1] > 0) isAdj = true;
                if(i < cols-1 && arr[i+1] > 0) isAdj = true;
                if(isAdj && arr[i] < maxHeight) candidates.push(i);
            }
            
            if(candidates.length === 0) {
                for(let i=0; i<cols; i++) {
                    if(arr[i] < maxHeight) { candidates.push(i); }
                }
            }
            
            if(candidates.length === 0) break;

            const pick = candidates[Math.floor(Math.random() * candidates.length)];
            arr[pick]++;
            placed++;
            failCount++;
            if(failCount > 100) break;
        }
        return arr;
    }

    function generateStadium3D_Strict(n, size, maxHeight) {
        const grid = Array(size).fill(0).map(() => Array(size).fill(0));
        let placed = 0;
        let failCount = 0;
        while(placed < n) {
            let candidates = [];
            for(let x=0; x<size; x++) {
                for(let z=0; z<size; z++) {
                    const h = grid[x][z];
                    if (h >= maxHeight) continue;
                    let canRaise = true;
                    if (x < size-1 && (h + 1) > grid[x+1][z]) canRaise = false;
                    if (z < size-1 && (h + 1) > grid[x][z+1]) canRaise = false;
                    if (canRaise) candidates.push({x, z});
                }
            }
            if (candidates.length === 0) break;
            const pick = candidates[Math.floor(Math.random() * candidates.length)];
            grid[pick.x][pick.z]++;
            placed++;
            failCount++;
            if(failCount > 100) break;
        }
        return grid;
    }

    function renderQueue() {
        renderShape(UI.view1, STATE.current ? STATE.current.shape : [], STATE.is3DMode, STATE.randomAtPlay, STATE.currentModeKey);
        renderShape(UI.view2, STATE.queue[0] ? STATE.queue[0].shape : [], STATE.is3DMode, STATE.randomAtPlay, STATE.currentModeKey);
        renderShape(UI.view3, STATE.queue[1] ? STATE.queue[1].shape : [], STATE.is3DMode, STATE.randomAtPlay, STATE.currentModeKey);
    }

    function renderShape(el, shapeData, is3D, useRandom, modeKeyOverride) {
        el.innerHTML = '';
        if(!shapeData) return;

        const mk = modeKeyOverride || STATE.currentModeKey;
        const modeClass = 'mode-' + mk.toLowerCase();
        const randomMode = (useRandom !== undefined) ? useRandom : STATE.isRandomMode;

        if(is3D) {
            if(!Array.isArray(shapeData[0])) { render2D(el, shapeData, modeClass, randomMode); return; }
            render3D(el, shapeData, modeClass);
        } else {
            if(shapeData.length > 0 && Array.isArray(shapeData[0])) {
                let flat = [];
                shapeData.forEach(r => r.forEach(h => { if(h>0) flat.push(h); }));
                render2D(el, flat, modeClass, randomMode);
            } else {
                render2D(el, shapeData, modeClass, randomMode);
            }
        }
    }

    function render2D(el, arr, modeClass, randomMode) {
        let totalBlocks = 0;
        if(Array.isArray(arr)) totalBlocks = arr.reduce((sum, h) => sum + h, 0);
        if (totalBlocks <= 0) return;

        if (randomMode) {
            const container = document.createElement('div');
            container.className = 'cluster-container random-layout';
            el.appendChild(container);

            let positions = arr._rndPositions;

            if (!positions || positions.length !== totalBlocks) {
                positions = [];
                const used = [];

                const rect = el.getBoundingClientRect();
                const containerW = rect.width || window.innerWidth;
                const containerH = rect.height || (window.innerHeight * 0.5);
                
                /* ‚òÖ RESPONSIVE FIX: CSSÂ§âÊï∞„ÅÆÂÄ§„ÇíÂèñÂæó„Åô„Çã„Åã„ÄÅË®àÁÆó„ÅßÂãïÁöÑ„Å´„Çµ„Ç§„Ç∫„ÇíÊ±∫„ÇÅ„Çã ‚òÖ */
                // ‰ª•Ââç„ÅØÂõ∫ÂÆö27px„Å†„Å£„Åü„Åå„ÄÅ‰ªä„ÅØÁõ∏ÂØæ„Çµ„Ç§„Ç∫„Å´„Åô„Çã
                // ÁîªÈù¢ÂπÖ„ÅÆ7.5%Á®ãÂ∫¶ (CSS„Å®ÂêåÊúü)
                const computedSize = window.innerWidth * 0.075;
                const maxPx = 30;
                const blockS = Math.min(computedSize, maxPx); // CSS„ÅÆmin(7.5vw, 30px)„Å®Âêå„Åò„É≠„Ç∏„ÉÉ„ÇØ

                const topBandPct = 28;
                const bottomBandPct = 8;
                const sideMarginPct = 6;

                for (let i = 0; i < totalBlocks; i++) {
                    let bestCandidate = null;

                    for(let attempt=0; attempt<2000; attempt++) {
                         const xp = sideMarginPct + Math.random() * (100 - sideMarginPct*2);
                         const yp = topBandPct + Math.random() * (100 - topBandPct - bottomBandPct);

                         const xPx = (xp / 100) * containerW;
                         const yPx = (yp / 100) * containerH;

                         const l1 = xPx - blockS/2;
                         const t1 = yPx - blockS/2;
                         const r1 = l1 + blockS;
                         const b1 = t1 + blockS;

                         let isStrictlyOverlapping = false;
                         for(let u of used) {
                             const l2 = u.px.l, t2 = u.px.t, r2 = u.px.r, b2 = u.px.b;
                             if (!(r1 <= l2 || l1 >= r2 || b1 <= t2 || t1 >= b2)) {
                                 isStrictlyOverlapping = true;
                                 break;
                             }
                         }

                         if (!isStrictlyOverlapping) {
                             bestCandidate = {
                                 pct: {x: xp, y: yp},
                                 px: {l: l1, t: t1, r: r1, b: b1}
                             };
                             break;
                         }
                    }

                    if (!bestCandidate) {
                         const xp = sideMarginPct + Math.random() * (100 - sideMarginPct*2);
                         const yp = topBandPct + Math.random() * (100 - topBandPct - bottomBandPct);
                         bestCandidate = { pct: {x: xp, y: yp}, px: {l:0, t:0, r:0, b:0} };
                    }

                    used.push(bestCandidate);
                    positions.push(bestCandidate.pct);
                }
                arr._rndPositions = positions;
            }

            positions.forEach(p => {
                const b = document.createElement('div');
                b.className = 'block ' + modeClass + ' block-random';
                b.style.left = p.x + '%';
                b.style.top  = p.y + '%';
                b.style.transform = 'translate(-50%, -50%)';
                container.appendChild(b);
            });
            return;
        }

        const container = document.createElement('div');
        container.className = 'cluster-container';
        arr.forEach(h => {
            if(h === 0) return;
            const col = document.createElement('div'); col.className = 'block-column';
            for(let i=0; i<h; i++) {
                const b = document.createElement('div'); b.className = 'block ' + modeClass;
                col.appendChild(b);
            }
            container.appendChild(col);
        });
        el.appendChild(container);
    }

    function render3D(el, grid, modeClass) {
        const container = document.createElement('div'); container.className = 'cluster-container real-3d';
        const style = getComputedStyle(document.body);
        const blockSize = parseInt(style.getPropertyValue('--block-size-3d'));
        const gridSize = grid.length;
        const offset = (gridSize * blockSize) / 2 - (blockSize / 2);

        let cubes = [];
        grid.forEach((row, xIdx) => {
            row.forEach((height, zIdx) => {
                if(height === 0) return;
                for(let y=0; y<height; y++) {
                    const tx = (xIdx * blockSize) - offset;
                    const tz = (zIdx * blockSize) - offset;
                    const ty = y * blockSize;

                    cubes.push({
                        html: createCubeHTML(modeClass, tx, ty, tz),
                        sortKey: (xIdx - zIdx)
                    });
                }
            });
        });
        cubes.sort((a, b) => a.sortKey - b.sortKey);
        cubes.forEach(c => container.appendChild(c.html));
        el.appendChild(container);
    }

    function createCubeHTML(modeClass, tx, ty, tz) {
        const cube = document.createElement('div');
        cube.className = 'cube ' + modeClass;
        cube.style.transform = `translateX(${tx}px) translateY(${-ty}px) translateZ(${tz}px)`;
        ['front','back','left','right','top','bottom'].forEach(face => {
            const f = document.createElement('div'); f.className = 'face face-' + face;
            cube.appendChild(f);
        });
        return cube;
    }

    function triggerRipple(el) {
        if (!el) return;
        el.classList.remove('ripple');
        void el.offsetWidth;
        el.classList.add('ripple');
        setTimeout(() => el.classList.remove('ripple'), 350);
    }

    function gameOver(reason) {
        if(STATE.status === 'GAMEOVER') return;
        STATE.status = 'GAMEOVER';
        STATE.isInputBlocked = true;

        if(STATE.rafId) cancelAnimationFrame(STATE.rafId);
        document.querySelectorAll('.kb-key').forEach(k => k.classList.remove('active-state'));

        if(reason === "FINISHED") UI.victoryShutter.classList.add('active');
        else UI.failShutter.classList.add('active');

        const answeredCount = (reason === 'FINISHED') ? MODES[STATE.currentModeKey].count : STATE.questionCount;
        const totalSec = Math.max(0.1, STATE.totalPlayTime);
        let ch = Math.floor((answeredCount / totalSec) * 3600);
        if(ch > CONFIG.capCh) ch = CONFIG.capCh;

        const resultData = {
            modeName: STATE.currentModeKey,
            is3D: STATE.is3DMode,
            isRandom: STATE.randomAtPlay,
            score: ch,
            totalTime: totalSec.toFixed(2),
            count: answeredCount,
            reason: reason,
            missedLog: [...STATE.missedLog],
            statsDetail: JSON.parse(JSON.stringify(STATE.statsDetail)),
            isNewRecord: false,
            unlockEvent: null,
            rank: 'F'
        };

        const wasNormalLocked = isModeLocked('NORMAL');
        const wasHardLocked    = isModeLocked('HARD');
        const wasExtremeLocked= isModeLocked('EXTREME');

        if (reason === "FINISHED") {
            resultData.rank = getRankFromScore(ch, STATE.currentModeKey);

            const rankStore = currentRanksStore();
            const currentSavedRank = rankStore[STATE.currentModeKey];
            const newRankIdx = RANK_ORDER.indexOf(resultData.rank);
            const oldRankIdx = currentSavedRank ? RANK_ORDER.indexOf(currentSavedRank) : 99;
            if (newRankIdx < oldRankIdx) rankStore[STATE.currentModeKey] = resultData.rank;

            const previousBestModeScore = STATE.saveData.modeScores[STATE.currentModeKey] || 0;
            const previousBestEasyCH = STATE.saveData.bestEasyCH || 0;

            if (ch > previousBestModeScore) { STATE.saveData.modeScores[STATE.currentModeKey] = ch; resultData.isNewRecord = true; }
            if (STATE.currentModeKey === 'EASY' && ch > previousBestEasyCH) STATE.saveData.bestEasyCH = ch;
            if (ch > (STATE.saveData.bestCH || 0)) STATE.saveData.bestCH = ch;

            const nowNormalLocked = isModeLocked('NORMAL');
            const nowHardLocked    = isModeLocked('HARD');
            const nowExtremeLocked= isModeLocked('EXTREME');

            if (wasExtremeLocked && !nowExtremeLocked) resultData.unlockEvent = 'EXTREME';
            else if (wasHardLocked && !nowHardLocked) resultData.unlockEvent = 'HARD';
            else if (wasNormalLocked && !nowNormalLocked) resultData.unlockEvent = 'NORMAL';
        }

        STATE.history.push(resultData);
        STATE.historyIndex = STATE.history.length - 1;

        setTimeout(() => { showHistoryResult(STATE.historyIndex); }, 1000);
    }

    function changeHistory(delta) {
        const newIdx = STATE.historyIndex + delta;
        if(newIdx >= 0 && newIdx < STATE.history.length) {
            STATE.historyIndex = newIdx;
            showHistoryResult(newIdx);
        }
    }

    function computeNextRankLine(data) {
        if (data.reason !== 'FINISHED') return '';
        const idx = RANK_ORDER.indexOf(data.rank);
        if (idx <= 0) return `<div class="next-rank-line">MAX RANK</div>`; // GOD

        const nextRank = RANK_ORDER[idx - 1];
        const thresholds = MODES[data.modeName].rankThresholds;

        const map = { GOD:'god', Z:'z', S:'s', A:'a', B:'b', C:'c', D:'f', F:'f' };
        const key = map[nextRank];
        const target = (thresholds && key in thresholds) ? thresholds[key] : null;
        if (target === null) return '';

        const need = Math.max(0, target - data.score);
        
        const label = (nextRank === 'GOD' || nextRank === 'Z') ? '???' : nextRank;
        
        return `<div class="next-rank-line">NEXT RANK ${label}: +${need.toLocaleString()} ch</div>`;
    }

    function showHistoryResult(index) {
        STATE.isInputBlocked = false;
        const data = STATE.history[index];

        UI.virtualKeyboard.style.visibility = 'hidden';

        const oldSvg = UI.slot1.querySelector('.slot-timer-svg');
        if(oldSvg) oldSvg.remove();
        UI.slot1.style.border = 'none';

        UI.failShutter.style.display = 'none';

        UI.histPrev.disabled = (index === 0);
        UI.histNext.disabled = (index === STATE.history.length - 1);
        UI.histPrev.style.opacity = (index === 0) ? '0' : '1';
        UI.histNext.style.opacity = (index === STATE.history.length - 1) ? '0' : '1';

        const modeLabel = getModeDisplayName(data.modeName);
        UI.resModeLabel.innerText = data.isRandom ? `${modeLabel} (RND)` : modeLabel;
        const modeColor = MODES[data.modeName].color;
        UI.resModeLabel.style.color = modeColor;
        UI.resModeLabel.style.borderColor = modeColor;

        let rankClass = 'rank-d';
        let displayText = data.rank;
        let isNiceTry = false;

        if (data.rank === 'GOD') rankClass = 'rank-god';
        else if (data.rank === 'Z') rankClass = 'rank-z';
        else if (data.rank === 'S') rankClass = 'rank-s';
        else if (data.rank === 'A') rankClass = 'rank-a';
        else if (data.rank === 'B') rankClass = 'rank-b';
        else if (data.rank === 'C') rankClass = 'rank-c';
        else if (data.rank === 'F') {
            rankClass = 'rank-nicetry';
            displayText = "NICE TRY";
            isNiceTry = true;
        } else {
            rankClass = 'rank-f'; 
        }

        UI.resRankChar.innerText = displayText;
        UI.resRankChar.className = 'rank-char ' + rankClass;

        if (isNiceTry) {
            if(UI.resRankLabelText) UI.resRankLabelText.style.display = 'none';
        } else {
            if(UI.resRankLabelText) UI.resRankLabelText.style.display = 'block';
        }

        // Apply background style class for ranks
        UI.resultCardContainer.className = 'result-card'; // Reset
        
        // Remove particles if any
        const particles = UI.resultCardContainer.querySelectorAll('.particle-fx');
        particles.forEach(p => p.remove());

        if (data.rank === 'GOD') {
            UI.resultCardContainer.classList.add('bg-god');
            // GOD Particles: Rising Light
            for(let i=0; i<40; i++) {
                const p = document.createElement('div');
                p.className = 'god-particle particle-fx';
                p.style.left = Math.random() * 100 + '%';
                const h = 50 + Math.random() * 150;
                p.style.height = h + 'px';
                
                // Animation duration & delay
                const dur = 2 + Math.random() * 3;
                p.style.animationDuration = dur + 's';
                p.style.animationDelay = (Math.random() * 5) + 's';
                
                UI.resultCardContainer.appendChild(p);
            }
        }
        else if (data.rank === 'Z') {
            UI.resultCardContainer.classList.add('bg-z');
            // Z Particles: Endless Embers
            for(let i=0; i<60; i++) {
                const p = document.createElement('div');
                p.className = 'z-particle particle-fx';
                p.style.left = Math.random() * 100 + '%';
                
                const size = 2 + Math.random() * 5;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                
                const dur = 3 + Math.random() * 5; 
                p.style.animationDuration = dur + 's';
                
                // Spread delay so they appear continuously
                p.style.animationDelay = (Math.random() * 8) + 's'; 
                
                UI.resultCardContainer.appendChild(p);
            }
        }
        else if (data.rank === 'S') UI.resultCardContainer.classList.add('bg-s');
        else if (data.rank === 'A') UI.resultCardContainer.classList.add('bg-a');
        else if (data.rank === 'B') UI.resultCardContainer.classList.add('bg-b');
        else if (data.rank === 'C') UI.resultCardContainer.classList.add('bg-c');
        else UI.resultCardContainer.classList.add('bg-d'); // D or F/Nice Try

        if (isNiceTry) {
            UI.resMsg.innerText = "";
            UI.resMsg.style.display = 'none';
        } else {
            UI.resMsg.innerText = (data.reason === "FINISHED") ? "" : data.reason;
            UI.resMsg.style.display = 'block';
            UI.resMsg.className = "";
            if (data.reason === "NICE TRY") UI.resMsg.classList.add("res-msg-nice");
            else if (data.reason === "TOO SLOW") UI.resMsg.classList.add("res-msg-nice");
            else if (data.reason === "TIME OVER") UI.resMsg.classList.add("res-msg-platinum");
        }

        UI.resStatusMsg.classList.remove('show');
        UI.resStatusMsg.className = 'res-status-msg';
        UI.resStatusMsg.innerText = '';

        UI.resUnlockWrapper.classList.remove('show');
        UI.resUnlockWrapper.innerHTML = '';

        if (data.reason === "FINISHED") {
            if (data.unlockEvent) {
                let ulColorClass = 'mode-normal';
                if(data.unlockEvent === 'HARD') ulColorClass = 'mode-hard';
                if(data.unlockEvent === 'EXTREME') ulColorClass = 'mode-extreme';
                
                UI.resUnlockWrapper.innerHTML = `
                    <div class="unlock-badge ${ulColorClass}">
                        <div class="main-text">UNLOCKED</div>
                        <div class="sub-text">${data.unlockEvent}</div>
                    </div>
                `;
                UI.resUnlockWrapper.classList.add('show');
            } else {
                UI.resStatusMsg.innerText = "STAGE CLEAR";
                UI.resStatusMsg.classList.add('status-clear');
                UI.resStatusMsg.classList.add('show');
            }
        }

        UI.newRecordBadge.classList.remove('show');
        if (data.isNewRecord) UI.newRecordBadge.classList.add('show');

        if(data.score > 0) {
            const avgTime = (data.totalTime / data.count).toFixed(1);
            const nextLine = computeNextRankLine(data);
            UI.resTotalBox.innerHTML = `
                <span class="total-label">TOTAL SCORE</span>
                ${Number(data.score).toLocaleString()} <span style="font-size:16px;">ch</span>
                <span class="total-avg-label"><span class="avg-text">AVG TIME</span><span class="avg-value">${avgTime}s</span></span>
                ${nextLine}`;
        } else {
            UI.resTotalBox.innerHTML = `
                <span class="total-label">TOTAL SCORE</span>
                0 <span style="font-size:16px;">ch</span>`;
        }

        UI.detailTableBody.innerHTML = '';
        const gradeList = [
            { k:'marvelous', l:'MARVELOUS', c:'var(--g-exc)' },
            { k:'excellent', l:'EXCELLENT', c:'var(--g-perf)' },
            { k:'great', l:'GREAT', c:'var(--g-grt)' },
            { k:'good', l:'GOOD', c:'var(--g-good)' },
            { k:'ok', l:'OK', c:'var(--g-ok)' }
        ];

        gradeList.forEach(g => {
            const info = data.statsDetail[g.k];
            if(info && info.count > 0) {
                const avg = info.time / info.count;
                let localScore = Math.floor((1 / Math.max(CONFIG.capPerItemSec, avg)) * 3600);
                if(localScore > CONFIG.capCh) localScore = CONFIG.capCh;

                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="dt-grade" style="color:${g.c}">${g.l}</td>
                    <td class="dt-count">${info.count}</td>
                    <td class="dt-avg">${avg.toFixed(1)}s</td>
                    <td class="dt-score">${localScore.toLocaleString()} <span class="dt-sub">ch</span></td>
                `;
                UI.detailTableBody.appendChild(tr);
            }
        });

        UI.missItemsRow.innerHTML = '';
        if(data.missedLog.length > 0) {
            UI.missLog.style.display = 'flex';
            data.missedLog.forEach(m => {
                const row = document.createElement('div'); row.className = 'feedback-row';
                const body = document.createElement('div'); body.className = 'fb-body';
                const inner = document.createElement('div');

                let cls = 'fb-body-inner';
                cls += m.is3D ? ' fb-3d' : ' fb-2d';
                if (m.mode === 'EXTREME') cls += ' fb-extreme';
                inner.className = cls;

                if (m.layout && Array.isArray(m.shape)) {
                    m.shape._rndPositions = m.layout.map(p => ({ x: p.x, y: p.y }));
                }

                renderShape(inner, m.shape, m.is3D, m.isRandom, m.mode);

                body.appendChild(inner);

                const footer = document.createElement('div'); footer.className = 'fb-footer';
                footer.innerHTML = `<span class="fb-lbl">INP</span><span class="fb-val-wrong">${m.input}</span> <span class="fb-lbl">ANS</span><span class="fb-val-correct">${m.answer}</span>`;

                row.appendChild(body);
                row.appendChild(footer);
                UI.missItemsRow.appendChild(row);
            });
        } else {
            UI.missLog.style.display = 'none';
        }

        UI.appWrapper.classList.add('showing-result');
        UI.resultModal.classList.add('show');
        UI.bottomUi.classList.remove('bottom-ui-dimmed');
    }
</script>
</body>
</html>